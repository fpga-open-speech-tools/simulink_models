-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\wickh\Documents\NIH\simulink_models\models\noise_suppression\hdlsrc\noise_suppression\noise_suppression_compute_statistics.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_compute_statistics
-- Source Path: noise_suppression/dataplane/Adaptive_Wiener_Filter Sample Based Filtering/compute statistics
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.noise_suppression_dataplane_pkg.ALL;

ENTITY noise_suppression_compute_statistics IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2048_1                      :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        data                              :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        mean                              :   OUT   vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        variance                          :   OUT   vector_of_std_logic_vector50(0 TO 1)  -- sfix50_En47 [2]
        );
END noise_suppression_compute_statistics;


ARCHITECTURE rtl OF noise_suppression_compute_statistics IS

  ATTRIBUTE multstyle : string;

  ATTRIBUTE multstyle OF rtl : ARCHITECTURE IS "dsp";

  -- Component Declarations
  COMPONENT noise_suppression_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : noise_suppression_SimpleDualPortRAM_generic
    USE ENTITY work.noise_suppression_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL data_signed                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL data_1                           : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL SignumOutput                     : vector_of_signed2(0 TO 1);  -- sfix2 [2]
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL Constant_out1_1                  : std_logic;
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Delay_out1_1                     : std_logic;
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL rd_13_reg                        : vector_of_unsigned32(0 TO 2);  -- ufix32 [3]
  SIGNAL rd_13_reg_next                   : vector_of_unsigned32(0 TO 2);  -- ufix32_En31 [3]
  SIGNAL Constant1_out1_1                 : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL exponential_moving_average_weight_out1 : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL rd_12_reg                        : vector_of_unsigned32(0 TO 2);  -- ufix32 [3]
  SIGNAL rd_12_reg_next                   : vector_of_unsigned32(0 TO 2);  -- ufix32_En31 [3]
  SIGNAL exponential_moving_average_weight_out1_1 : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL Switch1_out1                     : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL SignumOutput_1                   : vector_of_signed2(0 TO 1);  -- sfix2 [2]
  SIGNAL Switch1_out1_1                   : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL SignumOutput_2                   : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL mul_sign_mul_temp                : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL mul_sign_mul_temp_1              : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL mulOutput                        : vector_of_signed2(0 TO 1);  -- sfix2 [2]
  SIGNAL mulOutput_0                      : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL mulOutput_1                      : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL rd_5_out_1                       : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL rd_5_1_reg                       : vector_of_signed2(0 TO 3);  -- sfix2 [4]
  SIGNAL rd_5_out_2                       : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL rd_5_1_reg_1                     : vector_of_signed2(0 TO 3);  -- sfix2 [4]
  SIGNAL rd_5_1_reg_next                  : vector_of_signed2(0 TO 3);  -- sfix2 [4]
  SIGNAL rd_5_1_reg_next_1                : vector_of_signed2(0 TO 3);  -- sfix2 [4]
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Product_in0_dtc_in_abs_y         : vector_of_signed25(0 TO 1);  -- sfix25_En23 [2]
  SIGNAL Product_in0_dtc_in_abs_cast      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product_in0_dtc_in_abs_cast_1    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL data_2                           : vector_of_unsigned24(0 TO 1);  -- ufix24_En23 [2]
  SIGNAL data_3                           : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL data_4                           : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL data_5                           : vector_of_unsigned24(0 TO 1);  -- ufix24 [2]
  SIGNAL Switch1_out1_2                   : unsigned(53 DOWNTO 0);  -- ufix54
  SIGNAL slicedOutput                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL HwModeRegister3_reg              : vector_of_unsigned5(0 TO 1);  -- ufix5 [2]
  SIGNAL HwModeRegister3_reg_next         : vector_of_unsigned5(0 TO 1);  -- ufix5 [2]
  SIGNAL slicedOutput_1                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mulOutput_2                      : vector_of_unsigned29(0 TO 1);  -- ufix29 [2]
  SIGNAL slicedOutput_2                   : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL HwModeRegister1_reg              : vector_of_unsigned27(0 TO 1);  -- ufix27 [2]
  SIGNAL HwModeRegister1_reg_next         : vector_of_unsigned27(0 TO 1);  -- ufix27 [2]
  SIGNAL slicedOutput_3                   : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL mulOutput_3                      : vector_of_unsigned51(0 TO 1);  -- ufix51 [2]
  SIGNAL mulOutput_4                      : vector_of_unsigned29(0 TO 1);  -- ufix29 [2]
  SIGNAL mulOutput_5                      : vector_of_unsigned56(0 TO 1);  -- ufix56 [2]
  SIGNAL bitshiftoutput                   : vector_of_unsigned56(0 TO 1);  -- ufix56 [2]
  SIGNAL mulOutput_6                      : vector_of_unsigned51(0 TO 1);  -- ufix51 [2]
  SIGNAL mulOutput_7                      : vector_of_unsigned56(0 TO 1);  -- ufix56 [2]
  SIGNAL mulOutput_8                      : vector_of_unsigned57(0 TO 1);  -- ufix57 [2]
  SIGNAL mulOutput_9                      : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL mulOutput_10                     : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL SwitchComp_in2_uminus_in0        : signed(57 DOWNTO 0);  -- sfix58
  SIGNAL SwitchComp_in2_uminus_in0_1      : signed(57 DOWNTO 0);  -- sfix58
  SIGNAL mulOutput_11                     : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL mulOutput_12                     : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL mulOutput_0_1                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_13                     : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL switch_compare_2                 : std_logic;
  SIGNAL mulOutput_1_1                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_0_2                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_0_3                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_1_2                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_1_3                    : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL mulOutput_14                     : vector_of_signed57(0 TO 1);  -- sfix57 [2]
  SIGNAL mulOutput_15                     : vector_of_signed56(0 TO 1);  -- sfix56_En54 [2]
  SIGNAL Product_out1                     : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Product_out1_1                   : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL mergedDelay_waddr                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Constant2_out1                   : std_logic;
  SIGNAL Constant2_out1_1                 : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL mergedDelay_waddr_1              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedDelay_wrenb_1              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_1              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedOutput                     : unsigned(48 DOWNTO 0);  -- ufix49
  SIGNAL slicedInput                      : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Delay1_out1                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL delayIn1                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayIn0                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mergedInput                      : unsigned(48 DOWNTO 0);  -- ufix49
  SIGNAL mergedDelay_regin                : unsigned(48 DOWNTO 0);  -- ufix49
  SIGNAL mergedDelay_regout               : std_logic_vector(48 DOWNTO 0);  -- ufix49
  SIGNAL mergedDelay_regout_unsigned      : unsigned(48 DOWNTO 0);  -- ufix49
  SIGNAL slicedInput_1                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut0                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Delay1_out1_1                    : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL mergedOutput_1                   : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL slicedInput_2                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut1_1                      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL alpha_out1                       : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL delayIn1_1                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Add_out1                         : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Delay1_bypass_reg                : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL Delay1_bypass_reg_next           : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Add_out1_1                       : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Delay1_out1_2                    : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL alpha_mul_temp                   : signed(56 DOWNTO 0);  -- sfix57_En54
  SIGNAL alpha_cast                       : signed(55 DOWNTO 0);  -- sfix56_En54
  SIGNAL alpha_mul_temp_1                 : signed(56 DOWNTO 0);  -- sfix57_En54
  SIGNAL alpha_cast_1                     : signed(55 DOWNTO 0);  -- sfix56_En54
  SIGNAL delayIn0_1                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mergedInput_1                    : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regin_1              : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regout_1             : std_logic_vector(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regout_unsigned_1    : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL slicedInput_3                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut0_1                      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL alpha_out1_1                     : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Add_stage2_sub_cast              : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage2_sub_cast_1            : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage2_sub_cast_2            : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage2_sub_cast_3            : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_op_stage2                    : vector_of_signed26(0 TO 1);  -- sfix26_En23 [2]
  SIGNAL Add_op_stage2_1                  : vector_of_signed26(0 TO 1);  -- sfix26_En23 [2]
  SIGNAL Add_stage3_add_cast              : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage3_add_temp              : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage3_add_cast_1            : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Add_stage3_add_temp_1            : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL slicedInput_4                    : std_logic;  -- ufix1
  SIGNAL Delay3_out1_1                    : std_logic;
  SIGNAL Constant3_out1                   : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Constant3_out1_scalarexpand      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Add_out1_2                       : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Add1_out1                        : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Add1_out1_1                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Add1_out1_2                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Product1_out1                    : vector_of_signed48(0 TO 1);  -- sfix48_En46 [2]
  SIGNAL Product1_out1_1                  : vector_of_signed48(0 TO 1);  -- sfix48_En46 [2]
  SIGNAL Product1_out1_2                  : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Product1_out1_3                  : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL alpha1_mul_temp                  : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL alpha1_cast                      : signed(81 DOWNTO 0);  -- sfix82_En78
  SIGNAL alpha1_mul_temp_1                : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL alpha1_cast_1                    : signed(81 DOWNTO 0);  -- sfix82_En78
  SIGNAL alpha1_out1                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL alpha1_out1_1                    : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL mergedDelay_waddr_2              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedDelay_wrenb_2              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_2              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedOutput_2                   : unsigned(99 DOWNTO 0);  -- ufix100
  SIGNAL slicedInput_5                    : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL delayOut1_2                      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Delay4_out1                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL delayIn1_2                       : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Gain_out1                        : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Gain_out1_1                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Delay4_bypass_reg                : vector_of_signed50(0 TO 1);  -- sfix50 [2]
  SIGNAL Delay4_bypass_reg_next           : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Gain_out1_2                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL delayIn0_2                       : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL mergedInput_2                    : unsigned(99 DOWNTO 0);  -- ufix100
  SIGNAL mergedDelay_regin_2              : unsigned(99 DOWNTO 0);  -- ufix100
  SIGNAL mergedDelay_regout_2             : std_logic_vector(99 DOWNTO 0);  -- ufix100
  SIGNAL mergedDelay_regout_unsigned_2    : unsigned(99 DOWNTO 0);  -- ufix100
  SIGNAL slicedInput_6                    : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL delayOut0_2                      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Delay4_out1_1                    : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Add2_out1                        : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Add2_out1_1                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Gain_mul_temp                    : signed(83 DOWNTO 0);  -- sfix84_En78
  SIGNAL Gain_cast                        : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL Gain_mul_temp_1                  : signed(83 DOWNTO 0);  -- sfix84_En78
  SIGNAL Gain_cast_1                      : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL Gain_out1_3                      : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Switch2_out1                     : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Switch2_out1_1                   : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]

BEGIN
  -- ensure the variance is 0 for the first clock cycle
  -- 
  -- https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
  -- 
  -- $mean[k] = mean[k-1] + \alpha ( x[k] - mean[k-1] )$
  -- 
  -- exponential moving variance
  -- 
  -- exponential moving average implemented as a first order IIR filter
  -- 
  -- $var[k] = (1 - \alpha)\big(var[k-1] + \alpha ( x[k] - mean[k-1])^2\big)$

  u_ShiftRegisterRAM : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 49
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr_1),
              wr_en => mergedDelay_wrenb_1,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_1),
              rd_dout => mergedDelay_regout
              );

  u_ShiftRegisterRAM_1 : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 48
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_1),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              rd_dout => mergedDelay_regout_1
              );

  u_ShiftRegisterRAM_2 : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 100
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_2),
              wr_addr => std_logic_vector(mergedDelay_waddr_2),
              wr_en => mergedDelay_wrenb_2,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_2),
              rd_dout => mergedDelay_regout_2
              );

  outputgen2: FOR k IN 0 TO 1 GENERATE
    data_signed(k) <= signed(data(k));
  END GENERATE;

  rd_11_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      data_1(0) <= to_signed(16#000000#, 24);
      data_1(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        data_1(0) <= data_signed(0);
        data_1(1) <= data_signed(1);
      END IF;
    END IF;
  END PROCESS rd_11_process;


  
  SignumOutput(0) <= to_signed(16#1#, 2) WHEN data_1(0) > to_signed(16#000000#, 24) ELSE
      to_signed(-16#1#, 2) WHEN data_1(0) < to_signed(16#000000#, 24) ELSE
      to_signed(16#0#, 2);
  
  SignumOutput(1) <= to_signed(16#1#, 2) WHEN data_1(1) > to_signed(16#000000#, 24) ELSE
      to_signed(-16#1#, 2) WHEN data_1(1) < to_signed(16#000000#, 24) ELSE
      to_signed(16#0#, 2);

  Constant_out1 <= '1';

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant_out1_1 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_0 = '1' THEN
        Constant_out1_1 <= Constant_out1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  Delay_out1 <= Constant_out1_1;

  rd_0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_out1_1 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay_out1_1 <= Delay_out1;
      END IF;
    END IF;
  END PROCESS rd_0_process;


  Constant1_out1 <= unsigned'(X"80000000");

  rd_13_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_13_reg(0) <= to_unsigned(0, 32);
      rd_13_reg(1) <= to_unsigned(0, 32);
      rd_13_reg(2) <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        rd_13_reg(0) <= rd_13_reg_next(0);
        rd_13_reg(1) <= rd_13_reg_next(1);
        rd_13_reg(2) <= rd_13_reg_next(2);
      END IF;
    END IF;
  END PROCESS rd_13_process;

  Constant1_out1_1 <= rd_13_reg(2);
  rd_13_reg_next(0) <= Constant1_out1;
  rd_13_reg_next(1) <= rd_13_reg(0);
  rd_13_reg_next(2) <= rd_13_reg(1);

  exponential_moving_average_weight_out1 <= to_unsigned(8929246, 32);

  rd_12_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_12_reg(0) <= to_unsigned(0, 32);
      rd_12_reg(1) <= to_unsigned(0, 32);
      rd_12_reg(2) <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        rd_12_reg(0) <= rd_12_reg_next(0);
        rd_12_reg(1) <= rd_12_reg_next(1);
        rd_12_reg(2) <= rd_12_reg_next(2);
      END IF;
    END IF;
  END PROCESS rd_12_process;

  exponential_moving_average_weight_out1_1 <= rd_12_reg(2);
  rd_12_reg_next(0) <= exponential_moving_average_weight_out1;
  rd_12_reg_next(1) <= rd_12_reg(0);
  rd_12_reg_next(2) <= rd_12_reg(1);

  
  Switch1_out1 <= Constant1_out1_1 WHEN Delay_out1_1 = '0' ELSE
      exponential_moving_average_weight_out1_1;

  rd_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      SignumOutput_1(0) <= to_signed(16#0#, 2);
      SignumOutput_1(1) <= to_signed(16#0#, 2);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        SignumOutput_1(0) <= SignumOutput(0);
        SignumOutput_1(1) <= SignumOutput(1);
      END IF;
    END IF;
  END PROCESS rd_4_process;


  rd_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Switch1_out1_1 <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Switch1_out1_1 <= Switch1_out1;
      END IF;
    END IF;
  END PROCESS rd_6_process;


  
  SignumOutput_2 <= to_signed(16#1#, 2) WHEN Switch1_out1_1 > to_unsigned(0, 32) ELSE
      to_signed(16#0#, 2);

  mul_sign_mul_temp <= SignumOutput_1(0) * SignumOutput_2;
  mulOutput(0) <= mul_sign_mul_temp(1 DOWNTO 0);
  mul_sign_mul_temp_1 <= SignumOutput_1(1) * SignumOutput_2;
  mulOutput(1) <= mul_sign_mul_temp_1(1 DOWNTO 0);

  mulOutput_0 <= mulOutput(0);

  rd_5_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_5_1_reg(0) <= to_signed(16#0#, 2);
      rd_5_1_reg(1) <= to_signed(16#0#, 2);
      rd_5_1_reg(2) <= to_signed(16#0#, 2);
      rd_5_1_reg(3) <= to_signed(16#0#, 2);
      rd_5_1_reg_1(0) <= to_signed(16#0#, 2);
      rd_5_1_reg_1(1) <= to_signed(16#0#, 2);
      rd_5_1_reg_1(2) <= to_signed(16#0#, 2);
      rd_5_1_reg_1(3) <= to_signed(16#0#, 2);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        rd_5_1_reg(0) <= rd_5_1_reg_next(0);
        rd_5_1_reg(1) <= rd_5_1_reg_next(1);
        rd_5_1_reg(2) <= rd_5_1_reg_next(2);
        rd_5_1_reg(3) <= rd_5_1_reg_next(3);
        rd_5_1_reg_1(0) <= rd_5_1_reg_next_1(0);
        rd_5_1_reg_1(1) <= rd_5_1_reg_next_1(1);
        rd_5_1_reg_1(2) <= rd_5_1_reg_next_1(2);
        rd_5_1_reg_1(3) <= rd_5_1_reg_next_1(3);
      END IF;
    END IF;
  END PROCESS rd_5_1_process;

  rd_5_1_reg_next(0) <= mulOutput_0;
  rd_5_1_reg_next(1) <= rd_5_1_reg(0);
  rd_5_1_reg_next(2) <= rd_5_1_reg(1);
  rd_5_1_reg_next(3) <= rd_5_1_reg(2);
  rd_5_out_1 <= rd_5_1_reg(3);
  rd_5_1_reg_next_1(0) <= mulOutput_1;
  rd_5_1_reg_next_1(1) <= rd_5_1_reg_1(0);
  rd_5_1_reg_next_1(2) <= rd_5_1_reg_1(1);
  rd_5_1_reg_next_1(3) <= rd_5_1_reg_1(2);
  rd_5_out_2 <= rd_5_1_reg_1(3);

  
  switch_compare_1 <= '1' WHEN rd_5_out_1 > to_signed(16#0#, 2) ELSE
      '0';

  Product_in0_dtc_in_abs_cast <= resize(data_1(0), 25);
  
  Product_in0_dtc_in_abs_y(0) <=  - (Product_in0_dtc_in_abs_cast) WHEN data_1(0) < to_signed(16#000000#, 24) ELSE
      resize(data_1(0), 25);
  Product_in0_dtc_in_abs_cast_1 <= resize(data_1(1), 25);
  
  Product_in0_dtc_in_abs_y(1) <=  - (Product_in0_dtc_in_abs_cast_1) WHEN data_1(1) < to_signed(16#000000#, 24) ELSE
      resize(data_1(1), 25);
  data_2(0) <= unsigned(Product_in0_dtc_in_abs_y(0)(23 DOWNTO 0));
  data_2(1) <= unsigned(Product_in0_dtc_in_abs_y(1)(23 DOWNTO 0));

  data_3(0) <= data_2(0);
  data_3(1) <= data_2(1);

  rd_14_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      data_4(0) <= to_unsigned(16#000000#, 24);
      data_4(1) <= to_unsigned(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        data_4(0) <= data_3(0);
        data_4(1) <= data_3(1);
      END IF;
    END IF;
  END PROCESS rd_14_process;


  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      data_5(0) <= to_unsigned(16#000000#, 24);
      data_5(1) <= to_unsigned(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        data_5(0) <= data_4(0);
        data_5(1) <= data_4(1);
      END IF;
    END IF;
  END PROCESS reduced_process;


  Switch1_out1_2 <= resize(Switch1_out1, 54);

  slicedOutput <= Switch1_out1_2(31 DOWNTO 27);

  HwModeRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister3_reg(0) <= to_unsigned(16#00#, 5);
      HwModeRegister3_reg(1) <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        HwModeRegister3_reg(0) <= HwModeRegister3_reg_next(0);
        HwModeRegister3_reg(1) <= HwModeRegister3_reg_next(1);
      END IF;
    END IF;
  END PROCESS HwModeRegister3_process;

  slicedOutput_1 <= HwModeRegister3_reg(1);
  HwModeRegister3_reg_next(0) <= slicedOutput;
  HwModeRegister3_reg_next(1) <= HwModeRegister3_reg(0);

  mulOutput_2(0) <= data_5(0) * slicedOutput_1;
  mulOutput_2(1) <= data_5(1) * slicedOutput_1;

  slicedOutput_2 <= Switch1_out1_2(26 DOWNTO 0);

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister1_reg(0) <= to_unsigned(16#0000000#, 27);
      HwModeRegister1_reg(1) <= to_unsigned(16#0000000#, 27);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        HwModeRegister1_reg(0) <= HwModeRegister1_reg_next(0);
        HwModeRegister1_reg(1) <= HwModeRegister1_reg_next(1);
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;

  slicedOutput_3 <= HwModeRegister1_reg(1);
  HwModeRegister1_reg_next(0) <= slicedOutput_2;
  HwModeRegister1_reg_next(1) <= HwModeRegister1_reg(0);

  mulOutput_3(0) <= data_5(0) * slicedOutput_3;
  mulOutput_3(1) <= data_5(1) * slicedOutput_3;

  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_4(0) <= to_unsigned(16#00000000#, 29);
      mulOutput_4(1) <= to_unsigned(16#00000000#, 29);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mulOutput_4(0) <= mulOutput_2(0);
        mulOutput_4(1) <= mulOutput_2(1);
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  mulOutput_5(0) <= resize(mulOutput_4(0), 56);
  mulOutput_5(1) <= resize(mulOutput_4(1), 56);

  bitshiftoutput(0) <= mulOutput_5(0) sll 27;
  bitshiftoutput(1) <= mulOutput_5(1) sll 27;

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_6(0) <= to_unsigned(0, 51);
      mulOutput_6(1) <= to_unsigned(0, 51);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mulOutput_6(0) <= mulOutput_3(0);
        mulOutput_6(1) <= mulOutput_3(1);
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  mulOutput_7(0) <= resize(mulOutput_6(0), 56);
  mulOutput_7(1) <= resize(mulOutput_6(1), 56);

  mulOutput_8(0) <= resize(bitshiftoutput(0), 57) + resize(mulOutput_7(0), 57);
  mulOutput_8(1) <= resize(bitshiftoutput(1), 57) + resize(mulOutput_7(1), 57);

  mulOutput_9(0) <= signed(mulOutput_8(0));
  mulOutput_9(1) <= signed(mulOutput_8(1));

  rd_15_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_10(0) <= to_signed(0, 57);
      mulOutput_10(1) <= to_signed(0, 57);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mulOutput_10(0) <= mulOutput_9(0);
        mulOutput_10(1) <= mulOutput_9(1);
      END IF;
    END IF;
  END PROCESS rd_15_process;


  SwitchComp_in2_uminus_in0 <=  - (resize(mulOutput_10(0), 58));
  mulOutput_11(0) <= SwitchComp_in2_uminus_in0(56 DOWNTO 0);
  SwitchComp_in2_uminus_in0_1 <=  - (resize(mulOutput_10(1), 58));
  mulOutput_11(1) <= SwitchComp_in2_uminus_in0_1(56 DOWNTO 0);

  rd_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_12(0) <= to_signed(0, 57);
      mulOutput_12(1) <= to_signed(0, 57);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mulOutput_12(0) <= mulOutput_11(0);
        mulOutput_12(1) <= mulOutput_11(1);
      END IF;
    END IF;
  END PROCESS rd_3_process;


  mulOutput_0_1 <= mulOutput_12(0);

  rd_16_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulOutput_13(0) <= to_signed(0, 57);
      mulOutput_13(1) <= to_signed(0, 57);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mulOutput_13(0) <= mulOutput_10(0);
        mulOutput_13(1) <= mulOutput_10(1);
      END IF;
    END IF;
  END PROCESS rd_16_process;


  mulOutput_1 <= mulOutput(1);

  
  switch_compare_2 <= '1' WHEN rd_5_out_2 > to_signed(16#0#, 2) ELSE
      '0';

  mulOutput_1_1 <= mulOutput_12(1);

  mulOutput_0_2 <= mulOutput_13(0);

  
  mulOutput_0_3 <= mulOutput_0_1 WHEN switch_compare_1 = '0' ELSE
      mulOutput_0_2;

  mulOutput_1_2 <= mulOutput_13(1);

  
  mulOutput_1_3 <= mulOutput_1_1 WHEN switch_compare_2 = '0' ELSE
      mulOutput_1_2;

  mulOutput_14(0) <= mulOutput_0_3;
  mulOutput_14(1) <= mulOutput_1_3;

  mulOutput_15(0) <= mulOutput_14(0)(55 DOWNTO 0);
  mulOutput_15(1) <= mulOutput_14(1)(55 DOWNTO 0);

  Product_out1(0) <= mulOutput_15(0)(54 DOWNTO 31);
  Product_out1(1) <= mulOutput_15(1)(54 DOWNTO 31);

  rd_17_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1(0) <= to_signed(16#000000#, 24);
      Product_out1_1(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Product_out1_1(0) <= Product_out1(0);
        Product_out1_1(1) <= Product_out1(1);
      END IF;
    END IF;
  END PROCESS rd_17_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr <= to_unsigned(16#0#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_waddr <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 3
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr <= to_unsigned(16#1#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_raddr <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  Constant2_out1 <= '1';

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant2_out1_1 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_0 = '1' THEN
        Constant2_out1_1 <= Constant2_out1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  Delay3_out1 <= Constant2_out1_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 4
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr_1 <= to_unsigned(16#0#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr_1 >= to_unsigned(16#4#, 3) THEN 
          mergedDelay_waddr_1 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_waddr_1 <= mergedDelay_waddr_1 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_1_process;


  mergedDelay_wrenb_1 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 4
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr_1 <= to_unsigned(16#1#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr_1 >= to_unsigned(16#4#, 3) THEN 
          mergedDelay_raddr_1 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_raddr_1 <= mergedDelay_raddr_1 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_1_process;


  slicedInput <= mergedOutput(24 DOWNTO 1);

  delayOut1 <= signed(slicedInput);

  delayIn1 <= Delay1_out1(1);

  delayIn0 <= Delay1_out1(0);

  mergedInput <= unsigned(delayIn0) & unsigned(delayIn1) & Delay3_out1;

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin <= to_unsigned(0, 49);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput <= to_unsigned(0, 49);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  slicedInput_1 <= mergedOutput(48 DOWNTO 25);

  delayOut0 <= signed(slicedInput_1);

  Delay1_out1_1(0) <= delayOut0;
  Delay1_out1_1(1) <= delayOut1;

  slicedInput_2 <= mergedOutput_1(23 DOWNTO 0);

  delayOut1_1 <= signed(slicedInput_2);

  delayIn1_1 <= alpha_out1(1);

  Delay1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_bypass_reg(0) <= to_signed(16#000000#, 24);
      Delay1_bypass_reg(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        Delay1_bypass_reg(0) <= Delay1_bypass_reg_next(0);
        Delay1_bypass_reg(1) <= Delay1_bypass_reg_next(1);
      END IF;
    END IF;
  END PROCESS Delay1_bypass_process;

  
  Add_out1_1(0) <= Add_out1(0) WHEN enb_1_2048_1 = '1' ELSE
      Delay1_bypass_reg(0);
  
  Add_out1_1(1) <= Add_out1(1) WHEN enb_1_2048_1 = '1' ELSE
      Delay1_bypass_reg(1);
  Delay1_bypass_reg_next(0) <= Add_out1(0);
  Delay1_bypass_reg_next(1) <= Add_out1(1);

  Delay1_out1_2 <= Add_out1_1;

  rd_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_out1(0) <= to_signed(16#000000#, 24);
      Delay1_out1(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay1_out1(0) <= Delay1_out1_2(0);
        Delay1_out1(1) <= Delay1_out1_2(1);
      END IF;
    END IF;
  END PROCESS rd_1_process;


  -- CSD Encoding (8929246) : 01000100001000000001'0001'0; Cost (Adders) = 4
  alpha_mul_temp <= (((resize(Delay1_out1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57) + resize(Delay1_out1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57)) + resize(Delay1_out1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57)) - resize(Delay1_out1(0) & '0' & '0' & '0' & '0' & '0', 57)) - resize(Delay1_out1(0) & '0', 57);
  alpha_cast <= alpha_mul_temp(55 DOWNTO 0);
  alpha_out1(0) <= alpha_cast(54 DOWNTO 31);
  -- CSD Encoding (8929246) : 01000100001000000001'0001'0; Cost (Adders) = 4
  alpha_mul_temp_1 <= (((resize(Delay1_out1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57) + resize(Delay1_out1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57)) + resize(Delay1_out1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57)) - resize(Delay1_out1(1) & '0' & '0' & '0' & '0' & '0', 57)) - resize(Delay1_out1(1) & '0', 57);
  alpha_cast_1 <= alpha_mul_temp_1(55 DOWNTO 0);
  alpha_out1(1) <= alpha_cast_1(54 DOWNTO 31);

  delayIn0_1 <= alpha_out1(0);

  mergedInput_1 <= unsigned(delayIn0_1) & unsigned(delayIn1_1);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin_1 <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin_1 <= mergedInput_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_1_process;


  mergedDelay_regout_unsigned_1 <= unsigned(mergedDelay_regout_1);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput_1 <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput_1 <= mergedDelay_regout_unsigned_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_1_process;


  slicedInput_3 <= mergedOutput_1(47 DOWNTO 24);

  delayOut0_1 <= signed(slicedInput_3);

  alpha_out1_1(0) <= delayOut0_1;
  alpha_out1_1(1) <= delayOut1_1;

  Add_stage2_sub_cast <= resize(Product_out1_1(0), 26);
  Add_stage2_sub_cast_1 <= resize(alpha_out1_1(0), 26);
  Add_op_stage2(0) <= Add_stage2_sub_cast - Add_stage2_sub_cast_1;
  Add_stage2_sub_cast_2 <= resize(Product_out1_1(1), 26);
  Add_stage2_sub_cast_3 <= resize(alpha_out1_1(1), 26);
  Add_op_stage2(1) <= Add_stage2_sub_cast_2 - Add_stage2_sub_cast_3;

  rd_8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add_op_stage2_1(0) <= to_signed(16#0000000#, 26);
      Add_op_stage2_1(1) <= to_signed(16#0000000#, 26);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Add_op_stage2_1(0) <= Add_op_stage2(0);
        Add_op_stage2_1(1) <= Add_op_stage2(1);
      END IF;
    END IF;
  END PROCESS rd_8_process;


  Add_stage3_add_cast <= resize(Delay1_out1_1(0), 26);
  Add_stage3_add_temp <= Add_op_stage2_1(0) + Add_stage3_add_cast;
  Add_out1(0) <= Add_stage3_add_temp(23 DOWNTO 0);
  Add_stage3_add_cast_1 <= resize(Delay1_out1_1(1), 26);
  Add_stage3_add_temp_1 <= Add_op_stage2_1(1) + Add_stage3_add_cast_1;
  Add_out1(1) <= Add_stage3_add_temp_1(23 DOWNTO 0);

  outputgen1: FOR k IN 0 TO 1 GENERATE
    mean(k) <= std_logic_vector(Add_out1(k));
  END GENERATE;

  slicedInput_4 <= mergedOutput(0);

  
  Delay3_out1_1 <= '1' WHEN slicedInput_4 /= '0' ELSE
      '0';

  Constant3_out1 <= to_signed(0, 50);

  Constant3_out1_scalarexpand(0) <= Constant3_out1;
  Constant3_out1_scalarexpand(1) <= Constant3_out1;

  Add_out1_2 <= Add_out1_1;

  Add1_out1(0) <= data_signed(0) - Add_out1_2(0);
  Add1_out1(1) <= data_signed(1) - Add_out1_2(1);

  rd_21_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add1_out1_1(0) <= to_signed(16#000000#, 24);
      Add1_out1_1(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Add1_out1_1(0) <= Add1_out1(0);
        Add1_out1_1(1) <= Add1_out1(1);
      END IF;
    END IF;
  END PROCESS rd_21_process;


  reduced_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add1_out1_2(0) <= to_signed(16#000000#, 24);
      Add1_out1_2(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Add1_out1_2(0) <= Add1_out1_1(0);
        Add1_out1_2(1) <= Add1_out1_1(1);
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  Product1_out1(0) <= Add1_out1_2(0) * Add1_out1_2(0);
  Product1_out1(1) <= Add1_out1_2(1) * Add1_out1_2(1);

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_1(0) <= to_signed(0, 48);
      Product1_out1_1(1) <= to_signed(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Product1_out1_1(0) <= Product1_out1(0);
        Product1_out1_1(1) <= Product1_out1(1);
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  Product1_out1_2(0) <= resize(Product1_out1_1(0) & '0', 50);
  Product1_out1_2(1) <= resize(Product1_out1_1(1) & '0', 50);

  rd_71_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_3(0) <= to_signed(0, 50);
      Product1_out1_3(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Product1_out1_3(0) <= Product1_out1_2(0);
        Product1_out1_3(1) <= Product1_out1_2(1);
      END IF;
    END IF;
  END PROCESS rd_71_process;


  -- CSD Encoding (8929246) : 01000100001000000001'0001'0; Cost (Adders) = 4
  alpha1_mul_temp <= (((resize(Product1_out1_3(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83) + resize(Product1_out1_3(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83)) + resize(Product1_out1_3(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83)) - resize(Product1_out1_3(0) & '0' & '0' & '0' & '0' & '0', 83)) - resize(Product1_out1_3(0) & '0', 83);
  alpha1_cast <= alpha1_mul_temp(81 DOWNTO 0);
  alpha1_out1(0) <= alpha1_cast(80 DOWNTO 31);
  -- CSD Encoding (8929246) : 01000100001000000001'0001'0; Cost (Adders) = 4
  alpha1_mul_temp_1 <= (((resize(Product1_out1_3(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83) + resize(Product1_out1_3(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83)) + resize(Product1_out1_3(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 83)) - resize(Product1_out1_3(1) & '0' & '0' & '0' & '0' & '0', 83)) - resize(Product1_out1_3(1) & '0', 83);
  alpha1_cast_1 <= alpha1_mul_temp_1(81 DOWNTO 0);
  alpha1_out1(1) <= alpha1_cast_1(80 DOWNTO 31);

  rd_31_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha1_out1_1(0) <= to_signed(0, 50);
      alpha1_out1_1(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        alpha1_out1_1(0) <= alpha1_out1(0);
        alpha1_out1_1(1) <= alpha1_out1(1);
      END IF;
    END IF;
  END PROCESS rd_31_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr_2 <= to_unsigned(16#0#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr_2 >= to_unsigned(16#2#, 3) THEN 
          mergedDelay_waddr_2 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_waddr_2 <= mergedDelay_waddr_2 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_2_process;


  mergedDelay_wrenb_2 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 2
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr_2 <= to_unsigned(16#1#, 3);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr_2 >= to_unsigned(16#2#, 3) THEN 
          mergedDelay_raddr_2 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_raddr_2 <= mergedDelay_raddr_2 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_2_process;


  slicedInput_5 <= mergedOutput_2(49 DOWNTO 0);

  delayOut1_2 <= signed(slicedInput_5);

  delayIn1_2 <= Delay4_out1(1);

  rd_61_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Gain_out1_1(0) <= to_signed(0, 50);
      Gain_out1_1(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Gain_out1_1(0) <= Gain_out1(0);
        Gain_out1_1(1) <= Gain_out1(1);
      END IF;
    END IF;
  END PROCESS rd_61_process;


  Delay4_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_bypass_reg(0) <= to_signed(0, 50);
      Delay4_bypass_reg(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        Delay4_bypass_reg(0) <= Delay4_bypass_reg_next(0);
        Delay4_bypass_reg(1) <= Delay4_bypass_reg_next(1);
      END IF;
    END IF;
  END PROCESS Delay4_bypass_process;

  
  Gain_out1_2(0) <= Gain_out1_1(0) WHEN enb_1_2048_1 = '1' ELSE
      Delay4_bypass_reg(0);
  
  Gain_out1_2(1) <= Gain_out1_1(1) WHEN enb_1_2048_1 = '1' ELSE
      Delay4_bypass_reg(1);
  Delay4_bypass_reg_next(0) <= Gain_out1_1(0);
  Delay4_bypass_reg_next(1) <= Gain_out1_1(1);

  Delay4_out1 <= Gain_out1_2;

  delayIn0_2 <= Delay4_out1(0);

  mergedInput_2 <= unsigned(delayIn0_2) & unsigned(delayIn1_2);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin_2 <= to_unsigned(0, 100);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin_2 <= mergedInput_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_2_process;


  mergedDelay_regout_unsigned_2 <= unsigned(mergedDelay_regout_2);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput_2 <= to_unsigned(0, 100);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput_2 <= mergedDelay_regout_unsigned_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_2_process;


  slicedInput_6 <= mergedOutput_2(99 DOWNTO 50);

  delayOut0_2 <= signed(slicedInput_6);

  Delay4_out1_1(0) <= delayOut0_2;
  Delay4_out1_1(1) <= delayOut1_2;

  Add2_out1(0) <= alpha1_out1_1(0) + Delay4_out1_1(0);
  Add2_out1(1) <= alpha1_out1_1(1) + Delay4_out1_1(1);

  rd_41_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add2_out1_1(0) <= to_signed(0, 50);
      Add2_out1_1(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Add2_out1_1(0) <= Add2_out1(0);
        Add2_out1_1(1) <= Add2_out1(1);
      END IF;
    END IF;
  END PROCESS rd_41_process;


  -- CSD Encoding (2138554402) : 100000001'0001'00001'00000000100010; Cost (Adders) = 5
  Gain_mul_temp <= ((((resize(Add2_out1_1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84) - resize(Add2_out1_1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) - resize(Add2_out1_1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) - resize(Add2_out1_1(0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) + resize(Add2_out1_1(0) & '0' & '0' & '0' & '0' & '0', 84)) + resize(Add2_out1_1(0) & '0', 84);
  Gain_cast <= Gain_mul_temp(82 DOWNTO 0);
  Gain_out1_3(0) <= Gain_cast(80 DOWNTO 31);
  -- CSD Encoding (2138554402) : 100000001'0001'00001'00000000100010; Cost (Adders) = 5
  Gain_mul_temp_1 <= ((((resize(Add2_out1_1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84) - resize(Add2_out1_1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) - resize(Add2_out1_1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) - resize(Add2_out1_1(1) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 84)) + resize(Add2_out1_1(1) & '0' & '0' & '0' & '0' & '0', 84)) + resize(Add2_out1_1(1) & '0', 84);
  Gain_cast_1 <= Gain_mul_temp_1(82 DOWNTO 0);
  Gain_out1_3(1) <= Gain_cast_1(80 DOWNTO 31);

  rd_51_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Gain_out1(0) <= to_signed(0, 50);
      Gain_out1(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Gain_out1(0) <= Gain_out1_3(0);
        Gain_out1(1) <= Gain_out1_3(1);
      END IF;
    END IF;
  END PROCESS rd_51_process;


  
  Switch2_out1(0) <= Constant3_out1_scalarexpand(0) WHEN Delay3_out1_1 = '0' ELSE
      Gain_out1(0);
  
  Switch2_out1(1) <= Constant3_out1_scalarexpand(1) WHEN Delay3_out1_1 = '0' ELSE
      Gain_out1(1);

  rd_81_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Switch2_out1_1(0) <= to_signed(0, 50);
      Switch2_out1_1(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Switch2_out1_1(0) <= Switch2_out1(0);
        Switch2_out1_1(1) <= Switch2_out1(1);
      END IF;
    END IF;
  END PROCESS rd_81_process;


  outputgen: FOR k IN 0 TO 1 GENERATE
    variance(k) <= std_logic_vector(Switch2_out1_1(k));
  END GENERATE;

END rtl;

