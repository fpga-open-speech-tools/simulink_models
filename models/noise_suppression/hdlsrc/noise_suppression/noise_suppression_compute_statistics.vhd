-- -------------------------------------------------------------
-- 
-- File Name: /home/trevor/research/NIH_SBIR_R44_DC015443/simulink_models/models/noise_suppression/hdlsrc/noise_suppression/noise_suppression_compute_statistics.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_compute_statistics
-- Source Path: noise_suppression/dataplane/Adaptive_Wiener_Filter Sample Based Filtering/noise suppression blocks/noise 
-- suppression/compute statistic
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.noise_suppression_dataplane_pkg.ALL;

ENTITY noise_suppression_compute_statistics IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        data                              :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        valid                             :   IN    std_logic;
        mean                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        variance                          :   OUT   std_logic_vector(49 DOWNTO 0)  -- sfix50_En47
        );
END noise_suppression_compute_statistics;


ARCHITECTURE rtl OF noise_suppression_compute_statistics IS

  ATTRIBUTE multstyle : string;

  ATTRIBUTE multstyle OF rtl : ARCHITECTURE IS "dsp";

  -- Signals
  SIGNAL data_signed                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL data_1                           : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL valid_out                        : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL Delay_delOut                     : std_logic;
  SIGNAL Delay_ectrl                      : std_logic;
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Delay_last_value                 : std_logic;
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL exponential_moving_average_weight_out1 : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL Switch1_out1                     : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL Switch1_out1_1                   : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL Product_cast                     : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL Product_mul_temp                 : signed(64 DOWNTO 0);  -- sfix65_En59
  SIGNAL Product_cast_1                   : signed(63 DOWNTO 0);  -- sfix64_En59
  SIGNAL Product_out1                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product_out1_1                   : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL delayMatch4_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL delayMatch4_reg_next             : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL valid_out_1                      : std_logic;
  SIGNAL Delay1_delOut                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Add_out1                         : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Delay1_ectrl                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Delay1_out1                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Delay1_last_value                : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL alpha_mul_temp                   : signed(64 DOWNTO 0);  -- sfix65_En59
  SIGNAL alpha_cast                       : signed(63 DOWNTO 0);  -- sfix64_En59
  SIGNAL alpha_out1                       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Add_stage2_sub_cast              : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL Add_stage2_sub_cast_1            : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL Add_op_stage2                    : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL Add_stage3_add_cast              : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL Add_stage3_add_temp              : signed(33 DOWNTO 0);  -- sfix34_En28
  SIGNAL delayMatch1_reg                  : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL delayMatch1_reg_next             : vector_of_signed32(0 TO 3);  -- sfix32_En28 [4]
  SIGNAL Add_out1_1                       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL valid_out_2                      : std_logic;
  SIGNAL Constant2_out1                   : std_logic;
  SIGNAL Delay3_delOut                    : std_logic;
  SIGNAL Delay3_ectrl                     : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL Delay3_out1_1                    : std_logic;
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL reduced_reg_next                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Delay3_out1_2                    : std_logic;
  SIGNAL Constant3_out1                   : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL data_2                           : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Add1_out1                        : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Add1_out1_1                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Product1_mul_temp                : signed(63 DOWNTO 0);  -- sfix64_En56
  SIGNAL Product1_out1                    : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL HwModeRegister4_reg              : vector_of_signed50(0 TO 1);  -- sfix50 [2]
  SIGNAL HwModeRegister4_reg_next         : vector_of_signed50(0 TO 1);  -- sfix50_En47 [2]
  SIGNAL Product1_out1_1                  : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL kconst                           : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL kconst_1                         : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL alpha1_cast                      : signed(32 DOWNTO 0);  -- sfix33_En31
  SIGNAL alpha1_mul_temp                  : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL alpha1_cast_1                    : signed(81 DOWNTO 0);  -- sfix82_En78
  SIGNAL alpha1_out1                      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL alpha1_out1_1                    : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL delayMatch3_reg                  : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL delayMatch3_reg_next             : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL valid_out_3                      : std_logic;
  SIGNAL Delay4_delOut                    : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Gain_out1                        : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Delay4_ectrl                     : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Delay4_out1                      : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Delay4_last_value                : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Add2_out1                        : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL Gain_mul_temp                    : signed(83 DOWNTO 0);  -- sfix84_En78
  SIGNAL Gain_cast                        : signed(82 DOWNTO 0);  -- sfix83_En78
  SIGNAL Switch2_out1                     : signed(49 DOWNTO 0);  -- sfix50_En47

BEGIN
  -- ensure the variance is 0 for the first clock cycle
  -- 
  -- https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
  -- 
  -- $mean[k] = mean[k-1] + \alpha ( x[k] - mean[k-1] )$
  -- 
  -- exponential moving variance
  -- 
  -- exponential moving average implemented as a first order IIR filter
  -- 
  -- $var[k] = (1 - \alpha)\big(var[k-1] + \alpha ( x[k] - mean[k-1])^2\big)$

  -- 
  -- 
  data_signed <= signed(data);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      data_1 <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        data_1 <= data_signed;
      END IF;
    END IF;
  END PROCESS reduced_process;


  valid_out <= valid;

  Constant_out1 <= '1';

  
  Delay_ectrl <= Delay_delOut WHEN valid_out = '0' ELSE
      Constant_out1;

  Delay_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_delOut <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay_delOut <= Delay_ectrl;
      END IF;
    END IF;
  END PROCESS Delay_lowered_process;


  Delay_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_last_value <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay_last_value <= Delay_out1;
      END IF;
    END IF;
  END PROCESS Delay_bypass_process;


  
  Delay_out1 <= Delay_last_value WHEN valid_out = '0' ELSE
      Delay_delOut;

  Constant1_out1 <= unsigned'(X"80000000");

  exponential_moving_average_weight_out1 <= to_unsigned(8929246, 32);

  
  Switch1_out1 <= Constant1_out1 WHEN Delay_out1 = '0' ELSE
      exponential_moving_average_weight_out1;

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Switch1_out1_1 <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Switch1_out1_1 <= Switch1_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product_cast <= signed(resize(Switch1_out1_1, 33));
  Product_mul_temp <= data_1 * Product_cast;
  Product_cast_1 <= Product_mul_temp(63 DOWNTO 0);
  Product_out1 <= Product_cast_1(62 DOWNTO 31);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  delayMatch4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch4_reg(0) <= '0';
      delayMatch4_reg(1) <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch4_reg(0) <= delayMatch4_reg_next(0);
        delayMatch4_reg(1) <= delayMatch4_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch4_process;

  valid_out_1 <= delayMatch4_reg(1);
  delayMatch4_reg_next(0) <= valid;
  delayMatch4_reg_next(1) <= delayMatch4_reg(0);

  
  Delay1_ectrl <= Delay1_delOut WHEN valid_out_1 = '0' ELSE
      Add_out1;

  Delay1_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_delOut <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay1_delOut <= Delay1_ectrl;
      END IF;
    END IF;
  END PROCESS Delay1_lowered_process;


  Delay1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_last_value <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay1_last_value <= Delay1_out1;
      END IF;
    END IF;
  END PROCESS Delay1_bypass_process;


  
  Delay1_out1 <= Delay1_last_value WHEN valid_out_1 = '0' ELSE
      Delay1_delOut;

  alpha_mul_temp <= to_signed(8929246, 33) * Delay1_out1;
  alpha_cast <= alpha_mul_temp(63 DOWNTO 0);
  alpha_out1 <= alpha_cast(62 DOWNTO 31);

  Add_stage2_sub_cast <= resize(Product_out1_1, 34);
  Add_stage2_sub_cast_1 <= resize(alpha_out1, 34);
  Add_op_stage2 <= Add_stage2_sub_cast - Add_stage2_sub_cast_1;

  Add_stage3_add_cast <= resize(Delay1_out1, 34);
  Add_stage3_add_temp <= Add_op_stage2 + Add_stage3_add_cast;
  Add_out1 <= Add_stage3_add_temp(31 DOWNTO 0);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg(0) <= to_signed(0, 32);
      delayMatch1_reg(1) <= to_signed(0, 32);
      delayMatch1_reg(2) <= to_signed(0, 32);
      delayMatch1_reg(3) <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= delayMatch1_reg_next(0);
        delayMatch1_reg(1) <= delayMatch1_reg_next(1);
        delayMatch1_reg(2) <= delayMatch1_reg_next(2);
        delayMatch1_reg(3) <= delayMatch1_reg_next(3);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  Add_out1_1 <= delayMatch1_reg(3);
  delayMatch1_reg_next(0) <= Add_out1;
  delayMatch1_reg_next(1) <= delayMatch1_reg(0);
  delayMatch1_reg_next(2) <= delayMatch1_reg(1);
  delayMatch1_reg_next(3) <= delayMatch1_reg(2);

  mean <= std_logic_vector(Add_out1_1);

  valid_out_2 <= valid;

  Constant2_out1 <= '1';

  
  Delay3_ectrl <= Delay3_delOut WHEN valid_out_2 = '0' ELSE
      Constant2_out1;

  Delay3_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_delOut <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay3_delOut <= Delay3_ectrl;
      END IF;
    END IF;
  END PROCESS Delay3_lowered_process;


  
  Delay3_out1_1 <= Delay3_out1 WHEN valid_out_2 = '0' ELSE
      Delay3_delOut;

  reduced_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_out1 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay3_out1 <= Delay3_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  reduced_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_reg(0) <= '0';
      reduced_reg(1) <= '0';
      reduced_reg(2) <= '0';
      reduced_reg(3) <= '0';
      reduced_reg(4) <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        reduced_reg(0) <= reduced_reg_next(0);
        reduced_reg(1) <= reduced_reg_next(1);
        reduced_reg(2) <= reduced_reg_next(2);
        reduced_reg(3) <= reduced_reg_next(3);
        reduced_reg(4) <= reduced_reg_next(4);
      END IF;
    END IF;
  END PROCESS reduced_2_process;

  Delay3_out1_2 <= reduced_reg(4);
  reduced_reg_next(0) <= Delay3_out1;
  reduced_reg_next(1) <= reduced_reg(0);
  reduced_reg_next(2) <= reduced_reg(1);
  reduced_reg_next(3) <= reduced_reg(2);
  reduced_reg_next(4) <= reduced_reg(3);

  Constant3_out1 <= to_signed(0, 50);

  reduced_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      data_2 <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        data_2 <= data_1;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  Add1_out1 <= data_2 - Delay1_out1;

  reduced_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Add1_out1_1 <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Add1_out1_1 <= Add1_out1;
      END IF;
    END IF;
  END PROCESS reduced_4_process;


  Product1_mul_temp <= Add1_out1_1 * Add1_out1_1;
  Product1_out1 <= Product1_mul_temp(58 DOWNTO 9);

  HwModeRegister4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister4_reg(0) <= to_signed(0, 50);
      HwModeRegister4_reg(1) <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        HwModeRegister4_reg(0) <= HwModeRegister4_reg_next(0);
        HwModeRegister4_reg(1) <= HwModeRegister4_reg_next(1);
      END IF;
    END IF;
  END PROCESS HwModeRegister4_process;

  Product1_out1_1 <= HwModeRegister4_reg(1);
  HwModeRegister4_reg_next(0) <= Product1_out1;
  HwModeRegister4_reg_next(1) <= HwModeRegister4_reg(0);

  kconst <= to_unsigned(8929246, 32);

  HwModeRegister5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      kconst_1 <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        kconst_1 <= kconst;
      END IF;
    END IF;
  END PROCESS HwModeRegister5_process;


  alpha1_cast <= signed(resize(kconst_1, 33));
  alpha1_mul_temp <= Product1_out1_1 * alpha1_cast;
  alpha1_cast_1 <= alpha1_mul_temp(81 DOWNTO 0);
  alpha1_out1 <= alpha1_cast_1(80 DOWNTO 31);

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha1_out1_1 <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        alpha1_out1_1 <= alpha1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch3_reg(0) <= '0';
      delayMatch3_reg(1) <= '0';
      delayMatch3_reg(2) <= '0';
      delayMatch3_reg(3) <= '0';
      delayMatch3_reg(4) <= '0';
      delayMatch3_reg(5) <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch3_reg(0) <= delayMatch3_reg_next(0);
        delayMatch3_reg(1) <= delayMatch3_reg_next(1);
        delayMatch3_reg(2) <= delayMatch3_reg_next(2);
        delayMatch3_reg(3) <= delayMatch3_reg_next(3);
        delayMatch3_reg(4) <= delayMatch3_reg_next(4);
        delayMatch3_reg(5) <= delayMatch3_reg_next(5);
      END IF;
    END IF;
  END PROCESS delayMatch3_process;

  valid_out_3 <= delayMatch3_reg(5);
  delayMatch3_reg_next(0) <= valid;
  delayMatch3_reg_next(1) <= delayMatch3_reg(0);
  delayMatch3_reg_next(2) <= delayMatch3_reg(1);
  delayMatch3_reg_next(3) <= delayMatch3_reg(2);
  delayMatch3_reg_next(4) <= delayMatch3_reg(3);
  delayMatch3_reg_next(5) <= delayMatch3_reg(4);

  
  Delay4_ectrl <= Delay4_delOut WHEN valid_out_3 = '0' ELSE
      Gain_out1;

  Delay4_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_delOut <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay4_delOut <= Delay4_ectrl;
      END IF;
    END IF;
  END PROCESS Delay4_lowered_process;


  Delay4_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_last_value <= to_signed(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delay4_last_value <= Delay4_out1;
      END IF;
    END IF;
  END PROCESS Delay4_bypass_process;


  
  Delay4_out1 <= Delay4_last_value WHEN valid_out_3 = '0' ELSE
      Delay4_delOut;

  Add2_out1 <= alpha1_out1_1 + Delay4_out1;

  Gain_mul_temp <= to_signed(2138554402, 34) * Add2_out1;
  Gain_cast <= Gain_mul_temp(82 DOWNTO 0);
  Gain_out1 <= Gain_cast(80 DOWNTO 31);

  
  Switch2_out1 <= Constant3_out1 WHEN Delay3_out1_2 = '0' ELSE
      Gain_out1;

  variance <= std_logic_vector(Switch2_out1);

END rtl;

