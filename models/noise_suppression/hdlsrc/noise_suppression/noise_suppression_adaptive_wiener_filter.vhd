-- -------------------------------------------------------------
-- 
-- File Name: /home/trevor/research/NIH_SBIR_R44_DC015443/simulink_models/models/noise_suppression/hdlsrc/noise_suppression/noise_suppression_adaptive_wiener_filter.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_adaptive_wiener_filter
-- Source Path: noise_suppression/dataplane/Adaptive_Wiener_Filter Sample Based Filtering/noise suppression blocks/noise 
-- suppression/adaptive wiener filte
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY noise_suppression_adaptive_wiener_filter IS
  PORT( data                              :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        mean                              :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        variance                          :   IN    std_logic_vector(49 DOWNTO 0);  -- sfix50_En47
        noiseVariance                     :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En31
        estimatedSignal                   :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En28
        );
END noise_suppression_adaptive_wiener_filter;


ARCHITECTURE rtl OF noise_suppression_adaptive_wiener_filter IS

  ATTRIBUTE multstyle : string;

  -- Constants
  CONSTANT C_divbyzero_p                  : signed(50 DOWNTO 0) := 
    signed'("011111111111111111111111111111111111111111111111111");  -- sfix51
  CONSTANT C_divbyzero_n                  : signed(50 DOWNTO 0) := 
    signed'("100000000000000000000000000000000000000000000000000");  -- sfix51

  -- Signals
  SIGNAL data_signed                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mean_signed                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL variance_signed                  : signed(49 DOWNTO 0);  -- sfix50_En47
  SIGNAL noiseVariance_unsigned           : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL estimatedSignal_tmp              : signed(31 DOWNTO 0);  -- sfix32_En28

BEGIN
  data_signed <= signed(data);

  mean_signed <= signed(mean);

  variance_signed <= signed(variance);

  noiseVariance_unsigned <= unsigned(noiseVariance);

  adaptive_wiener_filter_output : PROCESS (data_signed, mean_signed, noiseVariance_unsigned, variance_signed)
    VARIABLE variance1 : signed(49 DOWNTO 0);
    VARIABLE estimatedSignalFullPrecision : signed(85 DOWNTO 0);
    VARIABLE c : signed(51 DOWNTO 0);
    VARIABLE c_0 : signed(51 DOWNTO 0);
    VARIABLE div_temp : signed(50 DOWNTO 0);
    VARIABLE cast : signed(49 DOWNTO 0);
    VARIABLE add_cast : signed(51 DOWNTO 0);
    VARIABLE add_cast_0 : signed(51 DOWNTO 0);
    VARIABLE slice_cast : signed(50 DOWNTO 0);
    VARIABLE slice_cast_0 : signed(50 DOWNTO 0);
    VARIABLE cast_0 : signed(50 DOWNTO 0);
    VARIABLE add_cast_1 : signed(85 DOWNTO 0);
    VARIABLE sub_cast : signed(32 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(32 DOWNTO 0);
    VARIABLE sub_temp : signed(32 DOWNTO 0);
    VARIABLE mul_temp : signed(84 DOWNTO 0);
    VARIABLE add_cast_2 : signed(85 DOWNTO 0);
  BEGIN
    variance1 := variance_signed;
    --MATLAB Function 'dataplane/Adaptive_Wiener_Filter Sample Based Filtering/noise suppression blocks/noise suppression/adaptive wiener filter': '<S11>:1'
    cast := signed(resize(noiseVariance_unsigned & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 50));
    IF variance_signed < cast THEN 
      --'<S11>:1:3'
      --'<S11>:1:4'
      variance1 := to_signed(0, 50);
    END IF;
    --'<S11>:1:7'
    add_cast := resize(variance1, 52);
    add_cast_0 := signed(resize(noiseVariance_unsigned & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 52));
    c := add_cast + add_cast_0;
    IF c = to_signed(0, 52) THEN 
      IF variance1 < to_signed(0, 50) THEN 
        c_0 := signed'(X"8000000000000");
      ELSE 
        c_0 := signed'(X"7FFFFFFFFFFFF");
      END IF;
    ELSE 
      slice_cast := variance1 & '0';
      IF slice_cast(50) = c(51) THEN 
        slice_cast_0 := C_divbyzero_p;
      ELSE 
        slice_cast_0 := C_divbyzero_n;
      END IF;
      cast_0 := variance1 & '0';
      IF c = 0 THEN 
        div_temp := slice_cast_0;
      ELSE 
        div_temp := cast_0 / c;
      END IF;
      c_0 := (resize(div_temp(50 DOWNTO 1), 52)) + ('0' & div_temp(0));
    END IF;
    add_cast_1 := resize(mean_signed, 86);
    sub_cast := resize(data_signed, 33);
    sub_cast_0 := resize(mean_signed, 33);
    sub_temp := sub_cast - sub_cast_0;
    mul_temp := c_0 * sub_temp;
    add_cast_2 := resize(mul_temp, 86);
    estimatedSignalFullPrecision := add_cast_1 + add_cast_2;
    --'<S11>:1:8'
    IF (estimatedSignalFullPrecision(85) = '0') AND (estimatedSignalFullPrecision(84 DOWNTO 31) /= "000000000000000000000000000000000000000000000000000000") THEN 
      estimatedSignal_tmp <= X"7FFFFFFF";
    ELSIF (estimatedSignalFullPrecision(85) = '1') AND (estimatedSignalFullPrecision(84 DOWNTO 31) /= "111111111111111111111111111111111111111111111111111111") THEN 
      estimatedSignal_tmp <= X"80000000";
    ELSE 
      estimatedSignal_tmp <= estimatedSignalFullPrecision(31 DOWNTO 0);
    END IF;
  END PROCESS adaptive_wiener_filter_output;


  estimatedSignal <= std_logic_vector(estimatedSignal_tmp);

END rtl;

