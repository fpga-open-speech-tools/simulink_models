-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\conno\Documents\NIH-GitHub\simulink_models\models\delay_and_sum_beamformer\hdlsrc\DSBF\DSBF_split_into_int_and_frac_parts.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DSBF_split_into_int_and_frac_parts
-- Source Path: DSBF/dataplane/Avalon Data Processing/delay signals/delay signal/split_into_int_and_frac_parts
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY DSBF_split_into_int_and_frac_parts IS
  PORT( delay                             :   IN    std_logic_vector(11 DOWNTO 0);  -- sfix12_En6
        integer_delay                     :   OUT   std_logic_vector(5 DOWNTO 0);  -- sfix6
        fractional_delay                  :   OUT   std_logic_vector(5 DOWNTO 0)  -- sfix6
        );
END DSBF_split_into_int_and_frac_parts;


ARCHITECTURE rtl OF DSBF_split_into_int_and_frac_parts IS

  ATTRIBUTE multstyle : string;

  -- Signals
  SIGNAL delay_signed                     : signed(11 DOWNTO 0);  -- sfix12_En6
  SIGNAL integer_delay_tmp                : signed(5 DOWNTO 0);  -- sfix6
  SIGNAL fractional_delay_tmp             : signed(5 DOWNTO 0);  -- sfix6

BEGIN
  delay_signed <= signed(delay);

  split_into_int_and_frac_parts_output : PROCESS (delay_signed)
    VARIABLE fractional_delay_temp : signed(12 DOWNTO 0);
    VARIABLE y1 : signed(5 DOWNTO 0);
    VARIABLE w1 : signed(14 DOWNTO 0);
    VARIABLE u2 : signed(25 DOWNTO 0);
    VARIABLE w2 : signed(13 DOWNTO 0);
    VARIABLE sub_cast : signed(12 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(12 DOWNTO 0);
    VARIABLE cast : signed(25 DOWNTO 0);
    VARIABLE add_cast : signed(14 DOWNTO 0);
    VARIABLE add_cast_0 : signed(15 DOWNTO 0);
    VARIABLE add_temp : signed(15 DOWNTO 0);
    VARIABLE cast_0 : signed(14 DOWNTO 0);
    VARIABLE sub_cast_1 : signed(14 DOWNTO 0);
    VARIABLE sub_cast_2 : signed(15 DOWNTO 0);
    VARIABLE sub_temp : signed(15 DOWNTO 0);
    VARIABLE cast_1 : signed(14 DOWNTO 0);
  BEGIN
    add_temp := to_signed(16#0000#, 16);
    sub_temp := to_signed(16#0000#, 16);
    w1 := to_signed(16#0000#, 15);
    add_cast := to_signed(16#0000#, 15);
    add_cast_0 := to_signed(16#0000#, 16);
    cast_0 := to_signed(16#0000#, 15);
    sub_cast_1 := to_signed(16#0000#, 15);
    sub_cast_2 := to_signed(16#0000#, 16);
    cast_1 := to_signed(16#0000#, 15);
    -- truncate the delay value to get the integer part
    y1 := delay_signed(11 DOWNTO 6) + ('0' & (delay_signed(11) AND (delay_signed(5) OR delay_signed(4) OR delay_signed(3) OR delay_signed(2) OR delay_signed(1) OR delay_signed(0))));
    -- get the fractional part of the delay and
    -- convert it to an integer at the upsampled clock rate
    sub_cast := resize(delay_signed, 13);
    sub_cast_0 := resize(y1 & '0' & '0' & '0' & '0' & '0' & '0', 13);
    fractional_delay_temp := sub_cast - sub_cast_0;
    u2 := resize(fractional_delay_temp & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 26);
    cast := resize(fractional_delay_temp & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 26);
    IF cast < to_signed(16#0000000#, 26) THEN 
      sub_cast_1 := (resize(u2(25 DOWNTO 12), 15)) + ('0' & (u2(11) OR u2(10) OR u2(9) OR u2(8) OR u2(7) OR u2(6) OR u2(5) OR u2(4) OR u2(3) OR u2(2) OR u2(1) OR u2(0)));
      sub_cast_2 := resize(sub_cast_1, 16);
      sub_temp := sub_cast_2 - to_signed(16#0001#, 16);
      IF (sub_temp(15) = '0') AND (sub_temp(14) /= '0') THEN 
        cast_1 := "011111111111111";
      ELSIF (sub_temp(15) = '1') AND (sub_temp(14) /= '1') THEN 
        cast_1 := "100000000000000";
      ELSE 
        cast_1 := sub_temp(14 DOWNTO 0);
      END IF;
      w1 := (resize(cast_1(14 DOWNTO 1), 15)) + ('0' & cast_1(0));
      IF (w1(14) = '0') AND (w1(13) /= '0') THEN 
        w2 := "01111111111111";
      ELSIF (w1(14) = '1') AND (w1(13) /= '1') THEN 
        w2 := "10000000000000";
      ELSE 
        w2 := w1(13 DOWNTO 0);
      END IF;
    ELSE 
      add_cast := resize(u2(25 DOWNTO 12), 15);
      add_cast_0 := resize(add_cast, 16);
      add_temp := add_cast_0 + to_signed(16#0001#, 16);
      IF (add_temp(15) = '0') AND (add_temp(14) /= '0') THEN 
        cast_0 := "011111111111111";
      ELSIF (add_temp(15) = '1') AND (add_temp(14) /= '1') THEN 
        cast_0 := "100000000000000";
      ELSE 
        cast_0 := add_temp(14 DOWNTO 0);
      END IF;
      w2 := cast_0(14 DOWNTO 1);
    END IF;
    integer_delay_tmp <= y1;
    IF (w2(13) = '0') AND (w2(12 DOWNTO 5) /= "00000000") THEN 
      fractional_delay_tmp <= "011111";
    ELSIF (w2(13) = '1') AND (w2(12 DOWNTO 5) /= "11111111") THEN 
      fractional_delay_tmp <= "100000";
    ELSE 
      fractional_delay_tmp <= w2(5 DOWNTO 0);
    END IF;
  END PROCESS split_into_int_and_frac_parts_output;


  integer_delay <= std_logic_vector(integer_delay_tmp);

  fractional_delay <= std_logic_vector(fractional_delay_tmp);

END rtl;

