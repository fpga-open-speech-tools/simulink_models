-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\conno\Documents\NIH-GitHub\simulink_models\models\delay_and_sum_beamformer\hdlsrc\DSBF\DSBF_cos_LUT.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DSBF_cos_LUT
-- Source Path: DSBF/dataplane/compute projections/compute cosine/cos LUT
-- Hierarchy Level: 3
-- 
-- Simulink subsystem description for DSBF/dataplane/compute projections/compute cosine/cos LUT:
-- 
-- This block was created using function approximation.
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DSBF_dataplane_pkg.ALL;

ENTITY DSBF_cos_LUT IS
  PORT( In1                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
        Out1                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
        );
END DSBF_cos_LUT;


ARCHITECTURE rtl OF DSBF_cos_LUT IS

  -- Constants
  CONSTANT LUT_data                       : vector_of_signed16(0 TO 45) := 
    (to_signed(16#4000#, 16), to_signed(16#3FF6#, 16), to_signed(16#3FD8#, 16), to_signed(16#3FA6#, 16),
     to_signed(16#3F61#, 16), to_signed(16#3F07#, 16), to_signed(16#3E9A#, 16), to_signed(16#3E19#, 16),
     to_signed(16#3D85#, 16), to_signed(16#3CDE#, 16), to_signed(16#3C24#, 16), to_signed(16#3B57#, 16),
     to_signed(16#3A78#, 16), to_signed(16#3986#, 16), to_signed(16#3882#, 16), to_signed(16#376D#, 16),
     to_signed(16#3646#, 16), to_signed(16#350F#, 16), to_signed(16#33C7#, 16), to_signed(16#326F#, 16),
     to_signed(16#3107#, 16), to_signed(16#2F90#, 16), to_signed(16#2E0A#, 16), to_signed(16#2C75#, 16),
     to_signed(16#2AD3#, 16), to_signed(16#2923#, 16), to_signed(16#2767#, 16), to_signed(16#259E#, 16),
     to_signed(16#23CA#, 16), to_signed(16#21EA#, 16), to_signed(16#2000#, 16), to_signed(16#1E0C#, 16),
     to_signed(16#1C0E#, 16), to_signed(16#1A08#, 16), to_signed(16#17FA#, 16), to_signed(16#15E4#, 16),
     to_signed(16#13C7#, 16), to_signed(16#11A4#, 16), to_signed(16#0F7C#, 16), to_signed(16#0D4E#, 16),
     to_signed(16#0B1D#, 16), to_signed(16#08E8#, 16), to_signed(16#06B1#, 16), to_signed(16#0477#, 16),
     to_signed(16#023C#, 16), to_signed(16#0000#, 16));  -- sfix16 [46]

  -- Signals
  SIGNAL In1_signed                       : signed(15 DOWNTO 0);  -- sfix16_En8
  SIGNAL LUT_out1                         : signed(15 DOWNTO 0);  -- sfix16_En14

BEGIN
  In1_signed <= signed(In1);

  LUT_output : PROCESS (In1_signed)
    VARIABLE dout_low : signed(15 DOWNTO 0);
    VARIABLE k : unsigned(5 DOWNTO 0);
    VARIABLE f : unsigned(31 DOWNTO 0);
    VARIABLE cast : signed(15 DOWNTO 0);
    VARIABLE cast_0 : signed(15 DOWNTO 0);
    VARIABLE in0 : signed(15 DOWNTO 0);
    VARIABLE add_cast : signed(49 DOWNTO 0);
    VARIABLE cast_1 : signed(32 DOWNTO 0);
    VARIABLE sub_cast : signed(16 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(16 DOWNTO 0);
    VARIABLE sub_temp : signed(16 DOWNTO 0);
    VARIABLE mul_temp : signed(49 DOWNTO 0);
    VARIABLE add_cast_0 : signed(48 DOWNTO 0);
    VARIABLE add_cast_1 : signed(49 DOWNTO 0);
    VARIABLE add_temp : signed(49 DOWNTO 0);
  BEGIN
    cast_0 := to_signed(16#0000#, 16);
    in0 := to_signed(16#0000#, 16);
    cast := to_signed(16#0000#, 16);
    IF In1_signed <= to_signed(16#0000#, 16) THEN 
      k := to_unsigned(16#00#, 6);
    ELSIF In1_signed >= to_signed(16#5A00#, 16) THEN 
      k := to_unsigned(16#2D#, 6);
    ELSE 
      cast := resize(In1_signed(15 DOWNTO 8), 16);
      cast_0 := SHIFT_RIGHT(cast, 1);
      k := unsigned(cast_0(5 DOWNTO 0));
    END IF;
    IF (In1_signed <= to_signed(16#0000#, 16)) OR (In1_signed >= to_signed(16#5A00#, 16)) THEN 
      f := to_unsigned(0, 32);
    ELSE 
      in0 := In1_signed AND to_signed(16#01FF#, 16);
      f := unsigned(in0(8 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0');
    END IF;
    dout_low := LUT_data(to_integer(k));
    IF k = to_unsigned(16#2D#, 6) THEN 
      NULL;
    ELSE 
      k := k + to_unsigned(16#01#, 6);
    END IF;
    add_cast := resize(dout_low & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 50);
    cast_1 := signed(resize(f, 33));
    sub_cast := resize(LUT_data(to_integer(k)), 17);
    sub_cast_0 := resize(dout_low, 17);
    sub_temp := sub_cast - sub_cast_0;
    mul_temp := cast_1 * sub_temp;
    add_cast_0 := mul_temp(48 DOWNTO 0);
    add_cast_1 := resize(add_cast_0, 50);
    add_temp := add_cast + add_cast_1;
    LUT_out1 <= add_temp(47 DOWNTO 32);
  END PROCESS LUT_output;


  Out1 <= std_logic_vector(LUT_out1);

END rtl;

