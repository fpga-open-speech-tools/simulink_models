-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\conno\Documents\NIH-GitHub\simulink_models\models\delay_and_sum_beamformer\hdlsrc\DSBF\DSBF_compute_cosine.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DSBF_compute_cosine
-- Source Path: DSBF/dataplane/compute projections/compute cosine
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY DSBF_compute_cosine IS
  PORT( angle                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
        Out1                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
        );
END DSBF_compute_cosine;


ARCHITECTURE rtl OF DSBF_compute_cosine IS

  -- Component Declarations
  COMPONENT DSBF_cos_LUT
    PORT( In1                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
          Out1                            :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : DSBF_cos_LUT
    USE ENTITY work.DSBF_cos_LUT(rtl);

  -- Signals
  SIGNAL angle_signed                     : signed(15 DOWNTO 0);  -- sfix16_En8
  SIGNAL Abs_y                            : signed(16 DOWNTO 0);  -- sfix17_En8
  SIGNAL Abs_cast                         : signed(16 DOWNTO 0);  -- sfix17_En8
  SIGNAL Abs_out1                         : signed(15 DOWNTO 0);  -- sfix16_En8
  SIGNAL cos_LUT_out1                     : std_logic_vector(15 DOWNTO 0);  -- ufix16

BEGIN
  -- cosine has even symmetry on [-90, 90]. 
  -- we can take advantage of that and only compute values on [0 90]

  -- This block was created using function approximation.
  u_cos_LUT : DSBF_cos_LUT
    PORT MAP( In1 => std_logic_vector(Abs_out1),  -- sfix16_En8
              Out1 => cos_LUT_out1  -- sfix16_En14
              );

  angle_signed <= signed(angle);

  Abs_cast <= resize(angle_signed, 17);
  
  Abs_y <=  - (Abs_cast) WHEN angle_signed < to_signed(16#0000#, 16) ELSE
      resize(angle_signed, 17);
  Abs_out1 <= Abs_y(15 DOWNTO 0);

  Out1 <= cos_LUT_out1;

END rtl;

