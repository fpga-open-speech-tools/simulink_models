-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\conno\Documents\NIH-GitHub\simulink_models\models\noise_suppression\hdlsrc\noise_suppression\noise_suppression_Adaptive_Wiener_Filter_Sample_Based_Filtering.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: noise_suppression_Adaptive_Wiener_Filter_Sample_Based_Filtering
-- Source Path: noise_suppression/dataplane/Adaptive_Wiener_Filter Sample Based Filtering
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.noise_suppression_dataplane_pkg.ALL;

ENTITY noise_suppression_Adaptive_Wiener_Filter_Sample_Based_Filtering IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2048_1                      :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        Sink_Data                         :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
        noise_variance                    :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
        enable                            :   IN    std_logic;
        data_out                          :   OUT   vector_of_std_logic_vector50(0 TO 1)  -- sfix50_En46 [2]
        );
END noise_suppression_Adaptive_Wiener_Filter_Sample_Based_Filtering;


ARCHITECTURE rtl OF noise_suppression_Adaptive_Wiener_Filter_Sample_Based_Filtering IS

  ATTRIBUTE multstyle : string;

  ATTRIBUTE multstyle OF rtl : ARCHITECTURE IS "dsp";

  -- Component Declarations
  COMPONENT noise_suppression_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT noise_suppression_compute_statistics
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          data                            :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          mean                            :   OUT   vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          variance                        :   OUT   vector_of_std_logic_vector50(0 TO 1)  -- sfix50_En47 [2]
          );
  END COMPONENT;

  COMPONENT noise_suppression_streaming_partition_streamed
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          in0                             :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          in1                             :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          in2                             :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
          in3                             :   IN    vector_of_std_logic_vector50(0 TO 1);  -- sfix50_En47 [2]
          globalSchedule                  :   IN    std_logic;
          out0                            :   OUT   vector_of_std_logic_vector25(0 TO 1);  -- sfix25_En23 [2]
          out1                            :   OUT   vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En20 [2]
          out2                            :   OUT   vector_of_std_logic_vector27(0 TO 1)  -- sfix27_En24 [2]
          );
  END COMPONENT;

  COMPONENT noise_suppression_Reciprocal1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          recip_in                        :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          recip_out                       :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En2
          );
  END COMPONENT;

  COMPONENT noise_suppression_Reciprocal2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          recip_in                        :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          recip_out                       :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En2
          );
  END COMPONENT;

  COMPONENT noise_suppression_streaming_partition_streamed_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          in0                             :   IN    std_logic;
          in1                             :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          in2                             :   IN    vector_of_std_logic_vector27(0 TO 1);  -- sfix27_En24 [2]
          in3                             :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En2 [2]
          in4                             :   IN    vector_of_std_logic_vector24(0 TO 1);  -- sfix24_En23 [2]
          in5                             :   IN    vector_of_std_logic_vector25(0 TO 1);  -- sfix25_En23 [2]
          enb_counter                     :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16
          globalSchedule                  :   IN    std_logic;
          out0                            :   OUT   vector_of_std_logic_vector50(0 TO 1)  -- sfix50_En46 [2]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : noise_suppression_SimpleDualPortRAM_generic
    USE ENTITY work.noise_suppression_SimpleDualPortRAM_generic(rtl);

  FOR ALL : noise_suppression_compute_statistics
    USE ENTITY work.noise_suppression_compute_statistics(rtl);

  FOR ALL : noise_suppression_streaming_partition_streamed
    USE ENTITY work.noise_suppression_streaming_partition_streamed(rtl);

  FOR ALL : noise_suppression_Reciprocal1
    USE ENTITY work.noise_suppression_Reciprocal1(rtl);

  FOR ALL : noise_suppression_Reciprocal2
    USE ENTITY work.noise_suppression_Reciprocal2(rtl);

  FOR ALL : noise_suppression_streaming_partition_streamed_block
    USE ENTITY work.noise_suppression_streaming_partition_streamed_block(rtl);

  -- Signals
  SIGNAL enable_1                         : std_logic;
  SIGNAL Sink_Data_signed                 : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Sink_Data_1                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL delayIn0                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayIn1                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mergedInput                      : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regin                : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_waddr                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_regout               : std_logic_vector(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regout_unsigned      : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedOutput                     : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL Sink_Data_2                      : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL mean                             : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL compute_statistics_out2          : vector_of_std_logic_vector50(0 TO 1);  -- ufix50 [2]
  SIGNAL noise_variance_1                 : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL noise_variance_2                 : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL ctr_2047_sig                     : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL enb_counter_ge_1_1               : std_logic;
  SIGNAL enb_counter_le_2_1               : std_logic;
  SIGNAL streaming_partition_enb_phase_1_1 : std_logic;
  SIGNAL Add2_out1_signed                 : vector_of_std_logic_vector25(0 TO 1);  -- ufix25 [2]
  SIGNAL Data_Type_Conversion3_out1_signed : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL variance_signed                  : vector_of_std_logic_vector27(0 TO 1);  -- ufix27 [2]
  SIGNAL delayIn0_1                       : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL delayIn1_1                       : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL mergedInput_1                    : unsigned(53 DOWNTO 0);  -- ufix54
  SIGNAL mergedDelay_regin_1              : unsigned(53 DOWNTO 0);  -- ufix54
  SIGNAL mergedDelay_waddr_1              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_wrenb_1              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_1              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_regout_1             : std_logic_vector(53 DOWNTO 0);  -- ufix54
  SIGNAL mergedDelay_regout_unsigned_1    : unsigned(53 DOWNTO 0);  -- ufix54
  SIGNAL mergedOutput_1                   : unsigned(53 DOWNTO 0);  -- ufix54
  SIGNAL delayIn0_2                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayIn1_2                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mergedInput_2                    : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regin_2              : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_waddr_2              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_wrenb_2              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_2              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_regout_2             : std_logic_vector(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedDelay_regout_unsigned_2    : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL mergedOutput_2                   : unsigned(47 DOWNTO 0);  -- ufix48
  SIGNAL delayIn0_3                       : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL delayIn1_3                       : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL mergedInput_3                    : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL mergedDelay_regin_3              : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL mergedDelay_waddr_3              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_wrenb_3              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_3              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL mergedDelay_regout_3             : std_logic_vector(49 DOWNTO 0);  -- ufix50
  SIGNAL mergedDelay_regout_unsigned_3    : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL mergedOutput_3                   : unsigned(49 DOWNTO 0);  -- ufix50
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 29);  -- ufix1 [30]
  SIGNAL delayMatch_reg_next              : std_logic_vector(0 TO 29);  -- ufix1 [30]
  SIGNAL enable_2                         : std_logic;
  SIGNAL slicedInput                      : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut0                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL slicedInput_1                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sink_Data_3                      : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Sink_Data_4                      : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL slicedInput_2                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL delayOut0_1                      : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL slicedInput_3                    : unsigned(26 DOWNTO 0);  -- ufix27
  SIGNAL delayOut1_1                      : signed(26 DOWNTO 0);  -- sfix27_En24
  SIGNAL variance                         : vector_of_signed27(0 TO 1);  -- sfix27_En24 [2]
  SIGNAL variance_1                       : vector_of_std_logic_vector27(0 TO 1);  -- ufix27 [2]
  SIGNAL Mux_out1                         : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL slicedInput_4                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut0_2                      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL slicedInput_5                    : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL delayOut1_2                      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL mean_1                           : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL mean_2                           : vector_of_std_logic_vector24(0 TO 1);  -- ufix24 [2]
  SIGNAL slicedInput_6                    : unsigned(24 DOWNTO 0);  -- ufix25
  SIGNAL delayOut0_3                      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL slicedInput_7                    : unsigned(24 DOWNTO 0);  -- ufix25
  SIGNAL delayOut1_3                      : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add2_out1                        : vector_of_signed25(0 TO 1);  -- sfix25_En23 [2]
  SIGNAL Add2_out1_1                      : vector_of_std_logic_vector25(0 TO 1);  -- ufix25 [2]
  SIGNAL enb_counter_ge_30_1              : std_logic;
  SIGNAL enb_counter_le_35_1              : std_logic;
  SIGNAL streaming_partition_enb_phase_30_5 : std_logic;
  SIGNAL Switch_out1                      : vector_of_std_logic_vector50(0 TO 1);  -- ufix50 [2]

BEGIN
  u_ShiftRegisterRAM : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 48
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              rd_dout => mergedDelay_regout
              );

  u_compute_statistics : noise_suppression_compute_statistics
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_2048_0 => enb_1_2048_0,
              data => Sink_Data,  -- sfix24_En23 [2]
              mean => mean,  -- sfix24_En23 [2]
              variance => compute_statistics_out2  -- sfix50_En47 [2]
              );

  u_streaming_partition_streamed : noise_suppression_streaming_partition_streamed
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in0 => Sink_Data_2,  -- sfix24_En23 [2]
              in1 => mean,  -- sfix24_En23 [2]
              in2 => std_logic_vector(noise_variance_2),  -- ufix16_En15
              in3 => compute_statistics_out2,  -- sfix50_En47 [2]
              globalSchedule => streaming_partition_enb_phase_1_1,
              out0 => Add2_out1_signed,  -- sfix25_En23 [2]
              out1 => Data_Type_Conversion3_out1_signed,  -- sfix24_En20 [2]
              out2 => variance_signed  -- sfix27_En24 [2]
              );

  u_ShiftRegisterRAM_generic : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 54
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_1),
              wr_addr => std_logic_vector(mergedDelay_waddr_1),
              wr_en => mergedDelay_wrenb_1,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_1),
              rd_dout => mergedDelay_regout_1
              );

  u_Reciprocal : noise_suppression_Reciprocal1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              recip_in => Data_Type_Conversion3_out1_signed(0),  -- sfix24_En20
              recip_out => Mux_out1(0)  -- sfix24_En2
              );

  u_ShiftRegisterRAM_1 : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 48
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_2),
              wr_addr => std_logic_vector(mergedDelay_waddr_2),
              wr_en => mergedDelay_wrenb_2,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_2),
              rd_dout => mergedDelay_regout_2
              );

  u_ShiftRegisterRAM_2 : noise_suppression_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 5,
                 DataWidth => 50
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_3),
              wr_addr => std_logic_vector(mergedDelay_waddr_3),
              wr_en => mergedDelay_wrenb_3,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_3),
              rd_dout => mergedDelay_regout_3
              );

  u_Reciprocal_1 : noise_suppression_Reciprocal2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              recip_in => Data_Type_Conversion3_out1_signed(1),  -- sfix24_En20
              recip_out => Mux_out1(1)  -- sfix24_En2
              );

  u_streaming_partition_streamed1 : noise_suppression_streaming_partition_streamed_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in0 => enable_2,
              in1 => Sink_Data_4,  -- sfix24_En23 [2]
              in2 => variance_1,  -- sfix27_En24 [2]
              in3 => Mux_out1,  -- sfix24_En2 [2]
              in4 => mean_2,  -- sfix24_En23 [2]
              in5 => Add2_out1_1,  -- sfix25_En23 [2]
              enb_counter => std_logic_vector(ctr_2047_sig),  -- ufix16
              globalSchedule => streaming_partition_enb_phase_30_5,
              out0 => Switch_out1  -- sfix50_En46 [2]
              );

  enable_1 <= enable;

  outputgen5: FOR k IN 0 TO 1 GENERATE
    Sink_Data_signed(k) <= signed(Sink_Data(k));
  END GENERATE;

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Sink_Data_1(0) <= to_signed(16#000000#, 24);
      Sink_Data_1(1) <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Sink_Data_1(0) <= Sink_Data_signed(0);
        Sink_Data_1(1) <= Sink_Data_signed(1);
      END IF;
    END IF;
  END PROCESS reduced_process;


  delayIn0 <= Sink_Data_1(0);

  delayIn1 <= Sink_Data_1(1);

  mergedInput <= unsigned(delayIn0) & unsigned(delayIn1);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 26
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#1A#, 5) THEN 
          mergedDelay_waddr <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 26
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr <= to_unsigned(16#01#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#1A#, 5) THEN 
          mergedDelay_raddr <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  outputgen4: FOR k IN 0 TO 1 GENERATE
    Sink_Data_2(k) <= std_logic_vector(Sink_Data_1(k));
  END GENERATE;

  noise_variance_1 <= unsigned(noise_variance);

  delayMatch8_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      noise_variance_2 <= to_unsigned(16#0000#, 16);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        noise_variance_2 <= noise_variance_1;
      END IF;
    END IF;
  END PROCESS delayMatch8_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2047
  ctr_2047_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_2047_sig <= to_unsigned(16#0000#, 16);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF ctr_2047_sig >= to_unsigned(16#07FF#, 16) THEN 
          ctr_2047_sig <= to_unsigned(16#0000#, 16);
        ELSE 
          ctr_2047_sig <= ctr_2047_sig + to_unsigned(16#0001#, 16);
        END IF;
      END IF;
    END IF;
  END PROCESS ctr_2047_process;


  
  enb_counter_ge_1_1 <= '1' WHEN ctr_2047_sig >= to_unsigned(16#0001#, 16) ELSE
      '0';

  
  enb_counter_le_2_1 <= '1' WHEN ctr_2047_sig <= to_unsigned(16#0002#, 16) ELSE
      '0';

  streaming_partition_enb_phase_1_1 <= enb_counter_ge_1_1 AND enb_counter_le_2_1;

  delayIn0_1 <= signed(variance_signed(0));

  delayIn1_1 <= signed(variance_signed(1));

  mergedInput_1 <= unsigned(delayIn0_1) & unsigned(delayIn1_1);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin_1 <= to_unsigned(0, 54);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin_1 <= mergedInput_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_1_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 25
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr_1 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr_1 >= to_unsigned(16#19#, 5) THEN 
          mergedDelay_waddr_1 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_waddr_1 <= mergedDelay_waddr_1 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_1_process;


  mergedDelay_wrenb_1 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 25
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr_1 <= to_unsigned(16#01#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr_1 >= to_unsigned(16#19#, 5) THEN 
          mergedDelay_raddr_1 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_raddr_1 <= mergedDelay_raddr_1 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_1_process;


  mergedDelay_regout_unsigned_1 <= unsigned(mergedDelay_regout_1);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput_1 <= to_unsigned(0, 54);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput_1 <= mergedDelay_regout_unsigned_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_1_process;


  delayIn0_2 <= signed(mean(0));

  delayIn1_2 <= signed(mean(1));

  mergedInput_2 <= unsigned(delayIn0_2) & unsigned(delayIn1_2);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin_2 <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin_2 <= mergedInput_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_2_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 26
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr_2 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr_2 >= to_unsigned(16#1A#, 5) THEN 
          mergedDelay_waddr_2 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_waddr_2 <= mergedDelay_waddr_2 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_2_process;


  mergedDelay_wrenb_2 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 26
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr_2 <= to_unsigned(16#01#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr_2 >= to_unsigned(16#1A#, 5) THEN 
          mergedDelay_raddr_2 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_raddr_2 <= mergedDelay_raddr_2 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_2_process;


  mergedDelay_regout_unsigned_2 <= unsigned(mergedDelay_regout_2);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput_2 <= to_unsigned(0, 48);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput_2 <= mergedDelay_regout_unsigned_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_2_process;


  delayIn0_3 <= signed(Add2_out1_signed(0));

  delayIn1_3 <= signed(Add2_out1_signed(1));

  mergedInput_3 <= unsigned(delayIn0_3) & unsigned(delayIn1_3);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_regin_3 <= to_unsigned(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedDelay_regin_3 <= mergedInput_3;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_3_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 25
  -- 
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_waddr_3 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_waddr_3 >= to_unsigned(16#19#, 5) THEN 
          mergedDelay_waddr_3 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_waddr_3 <= mergedDelay_waddr_3 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_3_process;


  mergedDelay_wrenb_3 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 25
  -- 
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedDelay_raddr_3 <= to_unsigned(16#01#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF mergedDelay_raddr_3 >= to_unsigned(16#19#, 5) THEN 
          mergedDelay_raddr_3 <= to_unsigned(16#00#, 5);
        ELSE 
          mergedDelay_raddr_3 <= mergedDelay_raddr_3 + to_unsigned(16#01#, 5);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_3_process;


  mergedDelay_regout_unsigned_3 <= unsigned(mergedDelay_regout_3);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mergedOutput_3 <= to_unsigned(0, 50);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        mergedOutput_3 <= mergedDelay_regout_unsigned_3;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_3_process;


  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg(0) <= '0';
      delayMatch_reg(1) <= '0';
      delayMatch_reg(2) <= '0';
      delayMatch_reg(3) <= '0';
      delayMatch_reg(4) <= '0';
      delayMatch_reg(5) <= '0';
      delayMatch_reg(6) <= '0';
      delayMatch_reg(7) <= '0';
      delayMatch_reg(8) <= '0';
      delayMatch_reg(9) <= '0';
      delayMatch_reg(10) <= '0';
      delayMatch_reg(11) <= '0';
      delayMatch_reg(12) <= '0';
      delayMatch_reg(13) <= '0';
      delayMatch_reg(14) <= '0';
      delayMatch_reg(15) <= '0';
      delayMatch_reg(16) <= '0';
      delayMatch_reg(17) <= '0';
      delayMatch_reg(18) <= '0';
      delayMatch_reg(19) <= '0';
      delayMatch_reg(20) <= '0';
      delayMatch_reg(21) <= '0';
      delayMatch_reg(22) <= '0';
      delayMatch_reg(23) <= '0';
      delayMatch_reg(24) <= '0';
      delayMatch_reg(25) <= '0';
      delayMatch_reg(26) <= '0';
      delayMatch_reg(27) <= '0';
      delayMatch_reg(28) <= '0';
      delayMatch_reg(29) <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= delayMatch_reg_next(0);
        delayMatch_reg(1) <= delayMatch_reg_next(1);
        delayMatch_reg(2) <= delayMatch_reg_next(2);
        delayMatch_reg(3) <= delayMatch_reg_next(3);
        delayMatch_reg(4) <= delayMatch_reg_next(4);
        delayMatch_reg(5) <= delayMatch_reg_next(5);
        delayMatch_reg(6) <= delayMatch_reg_next(6);
        delayMatch_reg(7) <= delayMatch_reg_next(7);
        delayMatch_reg(8) <= delayMatch_reg_next(8);
        delayMatch_reg(9) <= delayMatch_reg_next(9);
        delayMatch_reg(10) <= delayMatch_reg_next(10);
        delayMatch_reg(11) <= delayMatch_reg_next(11);
        delayMatch_reg(12) <= delayMatch_reg_next(12);
        delayMatch_reg(13) <= delayMatch_reg_next(13);
        delayMatch_reg(14) <= delayMatch_reg_next(14);
        delayMatch_reg(15) <= delayMatch_reg_next(15);
        delayMatch_reg(16) <= delayMatch_reg_next(16);
        delayMatch_reg(17) <= delayMatch_reg_next(17);
        delayMatch_reg(18) <= delayMatch_reg_next(18);
        delayMatch_reg(19) <= delayMatch_reg_next(19);
        delayMatch_reg(20) <= delayMatch_reg_next(20);
        delayMatch_reg(21) <= delayMatch_reg_next(21);
        delayMatch_reg(22) <= delayMatch_reg_next(22);
        delayMatch_reg(23) <= delayMatch_reg_next(23);
        delayMatch_reg(24) <= delayMatch_reg_next(24);
        delayMatch_reg(25) <= delayMatch_reg_next(25);
        delayMatch_reg(26) <= delayMatch_reg_next(26);
        delayMatch_reg(27) <= delayMatch_reg_next(27);
        delayMatch_reg(28) <= delayMatch_reg_next(28);
        delayMatch_reg(29) <= delayMatch_reg_next(29);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  enable_2 <= delayMatch_reg(29);
  delayMatch_reg_next(0) <= enable_1;
  delayMatch_reg_next(1) <= delayMatch_reg(0);
  delayMatch_reg_next(2) <= delayMatch_reg(1);
  delayMatch_reg_next(3) <= delayMatch_reg(2);
  delayMatch_reg_next(4) <= delayMatch_reg(3);
  delayMatch_reg_next(5) <= delayMatch_reg(4);
  delayMatch_reg_next(6) <= delayMatch_reg(5);
  delayMatch_reg_next(7) <= delayMatch_reg(6);
  delayMatch_reg_next(8) <= delayMatch_reg(7);
  delayMatch_reg_next(9) <= delayMatch_reg(8);
  delayMatch_reg_next(10) <= delayMatch_reg(9);
  delayMatch_reg_next(11) <= delayMatch_reg(10);
  delayMatch_reg_next(12) <= delayMatch_reg(11);
  delayMatch_reg_next(13) <= delayMatch_reg(12);
  delayMatch_reg_next(14) <= delayMatch_reg(13);
  delayMatch_reg_next(15) <= delayMatch_reg(14);
  delayMatch_reg_next(16) <= delayMatch_reg(15);
  delayMatch_reg_next(17) <= delayMatch_reg(16);
  delayMatch_reg_next(18) <= delayMatch_reg(17);
  delayMatch_reg_next(19) <= delayMatch_reg(18);
  delayMatch_reg_next(20) <= delayMatch_reg(19);
  delayMatch_reg_next(21) <= delayMatch_reg(20);
  delayMatch_reg_next(22) <= delayMatch_reg(21);
  delayMatch_reg_next(23) <= delayMatch_reg(22);
  delayMatch_reg_next(24) <= delayMatch_reg(23);
  delayMatch_reg_next(25) <= delayMatch_reg(24);
  delayMatch_reg_next(26) <= delayMatch_reg(25);
  delayMatch_reg_next(27) <= delayMatch_reg(26);
  delayMatch_reg_next(28) <= delayMatch_reg(27);
  delayMatch_reg_next(29) <= delayMatch_reg(28);

  slicedInput <= mergedOutput(47 DOWNTO 24);

  delayOut0 <= signed(slicedInput);

  slicedInput_1 <= mergedOutput(23 DOWNTO 0);

  delayOut1 <= signed(slicedInput_1);

  Sink_Data_3(0) <= delayOut0;
  Sink_Data_3(1) <= delayOut1;

  outputgen3: FOR k IN 0 TO 1 GENERATE
    Sink_Data_4(k) <= std_logic_vector(Sink_Data_3(k));
  END GENERATE;

  slicedInput_2 <= mergedOutput_1(53 DOWNTO 27);

  delayOut0_1 <= signed(slicedInput_2);

  slicedInput_3 <= mergedOutput_1(26 DOWNTO 0);

  delayOut1_1 <= signed(slicedInput_3);

  variance(0) <= delayOut0_1;
  variance(1) <= delayOut1_1;

  outputgen2: FOR k IN 0 TO 1 GENERATE
    variance_1(k) <= std_logic_vector(variance(k));
  END GENERATE;


  slicedInput_4 <= mergedOutput_2(47 DOWNTO 24);

  delayOut0_2 <= signed(slicedInput_4);

  slicedInput_5 <= mergedOutput_2(23 DOWNTO 0);

  delayOut1_2 <= signed(slicedInput_5);

  mean_1(0) <= delayOut0_2;
  mean_1(1) <= delayOut1_2;

  outputgen1: FOR k IN 0 TO 1 GENERATE
    mean_2(k) <= std_logic_vector(mean_1(k));
  END GENERATE;

  slicedInput_6 <= mergedOutput_3(49 DOWNTO 25);

  delayOut0_3 <= signed(slicedInput_6);

  slicedInput_7 <= mergedOutput_3(24 DOWNTO 0);

  delayOut1_3 <= signed(slicedInput_7);

  Add2_out1(0) <= delayOut0_3;
  Add2_out1(1) <= delayOut1_3;

  outputgen: FOR k IN 0 TO 1 GENERATE
    Add2_out1_1(k) <= std_logic_vector(Add2_out1(k));
  END GENERATE;

  
  enb_counter_ge_30_1 <= '1' WHEN ctr_2047_sig >= to_unsigned(16#001E#, 16) ELSE
      '0';

  
  enb_counter_le_35_1 <= '1' WHEN ctr_2047_sig <= to_unsigned(16#0023#, 16) ELSE
      '0';

  streaming_partition_enb_phase_30_5 <= enb_counter_ge_30_1 AND enb_counter_le_35_1;

  data_out <= Switch_out1;

END rtl;

