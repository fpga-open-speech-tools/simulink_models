-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\wickh\Documents\NIH\simulink_models\models\delay_and_sum_beamformer\hdlsrc\DSBF\DSBF_dataplane.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.01725e-08
-- Target subsystem base rate: 1.01725e-08
-- Explicit user oversample request: 128x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1.30208e-06
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- avalon_source_data            ce_out        1.30208e-06
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DSBF_dataplane
-- Source Path: DSBF/dataplane
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DSBF_dataplane_pkg.ALL;

ENTITY DSBF_dataplane IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        avalon_sink_data                  :   IN    vector_of_std_logic_vector32(0 TO 15);  -- sfix32_En28 [16]
        register_control_azimuth          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
        register_control_elevation        :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
        ce_out                            :   OUT   std_logic;
        avalon_source_data                :   OUT   vector_of_std_logic_vector32(0 TO 1)  -- sfix32_En28 [2]
        );
END DSBF_dataplane;


ARCHITECTURE rtl OF DSBF_dataplane IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT DSBF_dataplane_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_128_0                     :   OUT   std_logic;
          enb_1_128_1                     :   OUT   std_logic;
          enb_1_2048_0                    :   OUT   std_logic;
          enb_1_2048_1                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT DSBF_compute_projections
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          azimuth                         :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
          elevation                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En8
          sin_azimuth                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          cos_elevation                   :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          sin_elevation                   :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  COMPONENT DSBF_compute_delays
    PORT( sin_azimuth                     :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          cos_elevation                   :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          sin_elevation                   :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          delays                          :   OUT   vector_of_std_logic_vector12(0 TO 15)  -- sfix12_En6 [16]
          );
  END COMPONENT;

  COMPONENT DSBF_Avalon_Data_Processing
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_128_1                     :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb_1_128_0                     :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          Sink_Data                       :   IN    vector_of_std_logic_vector24(0 TO 15);  -- sfix24_En23 [16]
          delays                          :   IN    vector_of_std_logic_vector12(0 TO 15);  -- sfix12_En6 [16]
          Source_Data                     :   OUT   vector_of_std_logic_vector32(0 TO 1)  -- sfix32_En28 [2]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : DSBF_dataplane_tc
    USE ENTITY work.DSBF_dataplane_tc(rtl);

  FOR ALL : DSBF_compute_projections
    USE ENTITY work.DSBF_compute_projections(rtl);

  FOR ALL : DSBF_compute_delays
    USE ENTITY work.DSBF_compute_delays(rtl);

  FOR ALL : DSBF_Avalon_Data_Processing
    USE ENTITY work.DSBF_Avalon_Data_Processing(rtl);

  -- Signals
  SIGNAL enb_1_128_1                      : std_logic;
  SIGNAL enb_1_2048_1                     : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_128_0                      : std_logic;
  SIGNAL enb_1_2048_0                     : std_logic;
  SIGNAL register_control_azimuth_1       : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL register_control_elevation_1     : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL compute_projections_out1         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL compute_projections_out2         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL compute_projections_out3         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL compute_projections_out1_signed  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL compute_projections_out2_signed  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL compute_projections_out3_signed  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay2_bypass_reg                : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL compute_projections_out1_1       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay1_bypass_reg                : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL compute_projections_out2_1       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay_bypass_reg                 : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL compute_projections_out3_1       : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL delays                           : vector_of_std_logic_vector12(0 TO 15);  -- ufix12 [16]
  SIGNAL delays_signed                    : vector_of_signed12(0 TO 15);  -- sfix12_En6 [16]
  SIGNAL avalon_sink_data_signed          : vector_of_signed32(0 TO 15);  -- sfix32_En28 [16]
  SIGNAL Data_Type_Conversion_out1        : vector_of_signed24(0 TO 15);  -- sfix24_En23 [16]
  SIGNAL Data_Type_Conversion_out1_1      : vector_of_std_logic_vector24(0 TO 15);  -- ufix24 [16]
  SIGNAL delays_1                         : vector_of_signed12(0 TO 15);  -- sfix12_En6 [16]
  SIGNAL delays_2                         : vector_of_std_logic_vector12(0 TO 15);  -- ufix12 [16]
  SIGNAL Avalon_Data_Processing_out1      : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Avalon_Data_Processing_out1_signed : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]
  SIGNAL t_bypass_reg                     : vector_of_signed32(0 TO 1);  -- sfix32 [2]
  SIGNAL Data_Type_Conversion1_out1       : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]

BEGIN
  -- Control Signals that will be coming from Linux via
  -- memory mapped registers need to have names 
  -- containing the prefix "register_control_"
  -- (all lower case)
  -- 
  -- Avalon streaming interface signals need to have the
  -- names containing the prefix "avalon_" 
  -- (all lower case)

  u_dataplane_tc : DSBF_dataplane_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_128_0 => enb_1_128_0,
              enb_1_128_1 => enb_1_128_1,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1
              );

  u_compute_projections : DSBF_compute_projections
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              azimuth => register_control_azimuth_1,  -- sfix16_En8
              elevation => register_control_elevation_1,  -- sfix16_En8
              sin_azimuth => compute_projections_out1,  -- sfix16_En14
              cos_elevation => compute_projections_out2,  -- sfix16_En14
              sin_elevation => compute_projections_out3  -- sfix16_En14
              );

  u_compute_delays : DSBF_compute_delays
    PORT MAP( sin_azimuth => std_logic_vector(compute_projections_out1_1),  -- sfix16_En14
              cos_elevation => std_logic_vector(compute_projections_out2_1),  -- sfix16_En14
              sin_elevation => std_logic_vector(compute_projections_out3_1),  -- sfix16_En14
              delays => delays  -- sfix12_En6 [16]
              );

  u_Avalon_Data_Processing : DSBF_Avalon_Data_Processing
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_128_1 => enb_1_128_1,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_128_0 => enb_1_128_0,
              enb_1_2048_0 => enb_1_2048_0,
              Sink_Data => Data_Type_Conversion_out1_1,  -- sfix24_En23 [16]
              delays => delays_2,  -- sfix12_En6 [16]
              Source_Data => Avalon_Data_Processing_out1  -- sfix32_En28 [2]
              );

  register_control_azimuth_1 <= std_logic_vector(signed(register_control_azimuth));

  register_control_elevation_1 <= std_logic_vector(signed(register_control_elevation));

  compute_projections_out1_signed <= signed(compute_projections_out1);

  compute_projections_out2_signed <= signed(compute_projections_out2);

  compute_projections_out3_signed <= signed(compute_projections_out3);

  Delay2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_bypass_reg <= to_signed(16#0000#, 16);
    ELSIF rising_edge(clk) THEN
      IF enb_1_128_1 = '1' THEN
        Delay2_bypass_reg <= compute_projections_out1_signed;
      END IF;
    END IF;
  END PROCESS Delay2_bypass_process;

  
  compute_projections_out1_1 <= compute_projections_out1_signed WHEN enb_1_128_1 = '1' ELSE
      Delay2_bypass_reg;

  Delay1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_bypass_reg <= to_signed(16#0000#, 16);
    ELSIF rising_edge(clk) THEN
      IF enb_1_128_1 = '1' THEN
        Delay1_bypass_reg <= compute_projections_out2_signed;
      END IF;
    END IF;
  END PROCESS Delay1_bypass_process;

  
  compute_projections_out2_1 <= compute_projections_out2_signed WHEN enb_1_128_1 = '1' ELSE
      Delay1_bypass_reg;

  Delay_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_bypass_reg <= to_signed(16#0000#, 16);
    ELSIF rising_edge(clk) THEN
      IF enb_1_128_1 = '1' THEN
        Delay_bypass_reg <= compute_projections_out3_signed;
      END IF;
    END IF;
  END PROCESS Delay_bypass_process;

  
  compute_projections_out3_1 <= compute_projections_out3_signed WHEN enb_1_128_1 = '1' ELSE
      Delay_bypass_reg;

  outputgen5: FOR k IN 0 TO 15 GENERATE
    delays_signed(k) <= signed(delays(k));
  END GENERATE;

  outputgen4: FOR k IN 0 TO 15 GENERATE
    avalon_sink_data_signed(k) <= signed(avalon_sink_data(k));
  END GENERATE;


  Data_Type_Conversion_out1_gen: FOR ii IN 0 TO 15 GENERATE
    Data_Type_Conversion_out1(ii) <= avalon_sink_data_signed(ii)(28 DOWNTO 5);
  END GENERATE Data_Type_Conversion_out1_gen;


  outputgen3: FOR k IN 0 TO 15 GENERATE
    Data_Type_Conversion_out1_1(k) <= std_logic_vector(Data_Type_Conversion_out1(k));
  END GENERATE;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delays_1 <= (OTHERS => to_signed(16#000#, 12));
    ELSIF rising_edge(clk) THEN
      IF enb_1_128_0 = '1' THEN
        delays_1 <= delays_signed;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  outputgen2: FOR k IN 0 TO 15 GENERATE
    delays_2(k) <= std_logic_vector(delays_1(k));
  END GENERATE;

  outputgen1: FOR k IN 0 TO 1 GENERATE
    Avalon_Data_Processing_out1_signed(k) <= signed(Avalon_Data_Processing_out1(k));
  END GENERATE;

  t_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      t_bypass_reg <= (OTHERS => to_signed(0, 32));
    ELSIF rising_edge(clk) THEN
      IF enb_1_128_1 = '1' THEN
        t_bypass_reg <= Avalon_Data_Processing_out1_signed;
      END IF;
    END IF;
  END PROCESS t_bypass_process;

  
  Data_Type_Conversion1_out1 <= Avalon_Data_Processing_out1_signed WHEN enb_1_128_1 = '1' ELSE
      t_bypass_reg;

  outputgen: FOR k IN 0 TO 1 GENERATE
    avalon_source_data(k) <= std_logic_vector(Data_Type_Conversion1_out1(k));
  END GENERATE;

  ce_out <= enb_1_128_1;

END rtl;

