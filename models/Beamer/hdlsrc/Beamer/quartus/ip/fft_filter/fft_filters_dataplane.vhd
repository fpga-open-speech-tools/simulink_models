-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\wickh\Documents\NIH\Review\simulink_models\models\fft_filters\hdlsrc\fft_filters\fft_filters_dataplane.vhd
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.01725e-08
-- Target subsystem base rate: 1.01725e-08
-- Explicit user oversample request: 16x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1.01725e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- avalon_source_data            ce_out        1.01725e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fft_filters_dataplane
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.fft_filters_dataplane_pkg.ALL;

ENTITY fft_filters_dataplane IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        avalon_sink_data                  :   IN    vector_of_std_logic_vector32(0 TO 1);  -- sfix32_En28 [2]
        register_control_passthrough      :   IN    std_logic;
        register_control_filter_select    :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        ce_out                            :   OUT   std_logic;
        avalon_source_data                :   OUT   vector_of_std_logic_vector32(0 TO 1)  -- sfix32_En28 [2]
        );
END fft_filters_dataplane;


ARCHITECTURE rtl OF fft_filters_dataplane IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT fft_filters_dataplane_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_1_1                       :   OUT   std_logic;
          enb_1_16_0                      :   OUT   std_logic;
          enb_1_16_1                      :   OUT   std_logic;
          enb_1_2048_0                    :   OUT   std_logic;
          enb_1_2048_1                    :   OUT   std_logic;
          enb_1_2048_33                   :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT fft_filters_SimpleDualPortRAM_generic_block
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT fft_filters_FFT_Analysis_Synthesis_Left
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_16_0                      :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          enb_1_16_1                      :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb_1_2048_33                   :   IN    std_logic;
          signal_in                       :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
          Passthrough                     :   IN    std_logic;
          filter_select                   :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          signal_out                      :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
          );
  END COMPONENT;

  COMPONENT fft_filters_FFT_Analysis_Synthesis_Right
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_16_0                      :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          enb_1_16_1                      :   IN    std_logic;
          enb_1_2048_1                    :   IN    std_logic;
          enb_1_2048_33                   :   IN    std_logic;
          signal_in                       :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
          Passthrough                     :   IN    std_logic;
          filter_select                   :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          signal_out                      :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : fft_filters_dataplane_tc
    USE ENTITY work.fft_filters_dataplane_tc(rtl);

  FOR ALL : fft_filters_SimpleDualPortRAM_generic_block
    USE ENTITY work.fft_filters_SimpleDualPortRAM_generic_block(rtl);

  FOR ALL : fft_filters_FFT_Analysis_Synthesis_Left
    USE ENTITY work.fft_filters_FFT_Analysis_Synthesis_Left(rtl);

  FOR ALL : fft_filters_FFT_Analysis_Synthesis_Right
    USE ENTITY work.fft_filters_FFT_Analysis_Synthesis_Right(rtl);

  -- Signals
  SIGNAL enb_1_16_0                       : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_2048_0                     : std_logic;
  SIGNAL enb_1_16_1                       : std_logic;
  SIGNAL enb_1_2048_1                     : std_logic;
  SIGNAL enb_1_2048_33                    : std_logic;
  SIGNAL enb_1_1_1                        : std_logic;
  SIGNAL delayMatch2_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL register_control_passthrough_1   : std_logic;
  SIGNAL register_control_passthrough_2   : std_logic;
  SIGNAL avalon_sink_data_signed          : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]
  SIGNAL avalon_sink_data_1               : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]
  SIGNAL Data_Type_Conversion_out1        : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Data_Type_Conversion_out1_0      : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayMatch1_regin                : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL delayMatch1_waddr                : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL delayMatch1_wrenb                : std_logic;  -- ufix1
  SIGNAL delayMatch1_raddr                : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL delayMatch1_regout               : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL delayMatch1_regout_signed        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Demux_out1                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL DPRAM_bypass_reg                 : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL Demux_out1_1                     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Demux_out2                       : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL DPRAM1_bypass_reg                : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL Demux_out2_1                     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL register_control_passthrough_3   : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Demux_out1_scalarexpand          : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL Demux_out1_scalarexpand_dtc      : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]
  SIGNAL FFT_Analysis_Synthesis_Left_out1 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL FFT_Analysis_Synthesis_Left_out1_signed : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Data_Type_Conversion1_out1       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL FFT_Analysis_Synthesis_Right_out1 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL FFT_Analysis_Synthesis_Right_out1_signed : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Data_Type_Conversion2_out1       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Mux_out1                         : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]
  SIGNAL Switch_out1                      : vector_of_signed32(0 TO 1);  -- sfix32_En28 [2]

BEGIN
  u_dataplane_tc : fft_filters_dataplane_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_1_1 => enb_1_1_1,
              enb_1_16_0 => enb_1_16_0,
              enb_1_16_1 => enb_1_16_1,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_2048_33 => enb_1_2048_33
              );

  u_ShiftRegisterRAM_generic : fft_filters_SimpleDualPortRAM_generic_block
    GENERIC MAP( AddrWidth => 13,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(delayMatch1_regin),
              wr_addr => std_logic_vector(delayMatch1_waddr),
              wr_en => delayMatch1_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch1_raddr),
              rd_dout => delayMatch1_regout
              );

  u_FFT_Analysis_Synthesis_Left : fft_filters_FFT_Analysis_Synthesis_Left
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_16_0 => enb_1_16_0,
              enb => enb,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_16_1 => enb_1_16_1,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_2048_33 => enb_1_2048_33,
              signal_in => std_logic_vector(Demux_out1_1),  -- sfix24_En23
              Passthrough => register_control_passthrough,
              filter_select => register_control_filter_select,  -- ufix2
              signal_out => FFT_Analysis_Synthesis_Left_out1  -- sfix24_En23
              );

  u_FFT_Analysis_Synthesis_Right : fft_filters_FFT_Analysis_Synthesis_Right
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_16_0 => enb_1_16_0,
              enb => enb,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_16_1 => enb_1_16_1,
              enb_1_2048_1 => enb_1_2048_1,
              enb_1_2048_33 => enb_1_2048_33,
              signal_in => std_logic_vector(Demux_out2_1),  -- sfix24_En23
              Passthrough => register_control_passthrough,
              filter_select => register_control_filter_select,  -- ufix2
              signal_out => FFT_Analysis_Synthesis_Right_out1  -- sfix24_En23
              );

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch2_reg <= (OTHERS => '0');
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_0 = '1' THEN
        delayMatch2_reg(0) <= register_control_passthrough;
        delayMatch2_reg(1) <= delayMatch2_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  register_control_passthrough_1 <= delayMatch2_reg(1);

  register_control_passthrough_2 <= register_control_passthrough_1;

  outputgen1: FOR k IN 0 TO 1 GENERATE
    avalon_sink_data_signed(k) <= signed(avalon_sink_data(k));
  END GENERATE;

  avalon_sink_data_1 <= avalon_sink_data_signed;


  Data_Type_Conversion_out1_gen: FOR ii IN 0 TO 1 GENERATE
    Data_Type_Conversion_out1(ii) <= avalon_sink_data_1(ii)(28 DOWNTO 5);
  END GENERATE Data_Type_Conversion_out1_gen;


  Data_Type_Conversion_out1_0 <= Data_Type_Conversion_out1(0);

  -- Input register for RAM-based shift register delayMatch1
  delayMatch1_reginc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_regin <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch1_regin <= Data_Type_Conversion_out1_0;
      END IF;
    END IF;
  END PROCESS delayMatch1_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 4094
  -- 
  -- Write address counter for RAM-based shift register delayMatch1
  delayMatch1_wr_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_waddr <= to_unsigned(16#0000#, 13);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch1_waddr >= to_unsigned(16#0FFE#, 13) THEN 
          delayMatch1_waddr <= to_unsigned(16#0000#, 13);
        ELSE 
          delayMatch1_waddr <= delayMatch1_waddr + to_unsigned(16#0001#, 13);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch1_wr_process;


  delayMatch1_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 4094
  -- 
  -- Read address counter for RAM-based shift register delayMatch1
  delayMatch1_rd_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_raddr <= to_unsigned(16#0001#, 13);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        IF delayMatch1_raddr >= to_unsigned(16#0FFE#, 13) THEN 
          delayMatch1_raddr <= to_unsigned(16#0000#, 13);
        ELSE 
          delayMatch1_raddr <= delayMatch1_raddr + to_unsigned(16#0001#, 13);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch1_rd_process;


  delayMatch1_regout_signed <= signed(delayMatch1_regout);

  -- Output register for RAM-based shift register delayMatch1
  delayMatch1_regoutc_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Demux_out1 <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Demux_out1 <= delayMatch1_regout_signed;
      END IF;
    END IF;
  END PROCESS delayMatch1_regoutc_process;


  DPRAM_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      DPRAM_bypass_reg <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        DPRAM_bypass_reg <= Data_Type_Conversion_out1_0;
      END IF;
    END IF;
  END PROCESS DPRAM_bypass_process;

  
  Demux_out1_1 <= Data_Type_Conversion_out1_0 WHEN enb_1_2048_1 = '1' ELSE
      DPRAM_bypass_reg;

  Demux_out2 <= Data_Type_Conversion_out1(1);

  DPRAM1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      DPRAM1_bypass_reg <= to_signed(16#000000#, 24);
    ELSIF rising_edge(clk) THEN
      IF enb_1_2048_1 = '1' THEN
        DPRAM1_bypass_reg <= Demux_out2;
      END IF;
    END IF;
  END PROCESS DPRAM1_bypass_process;

  
  Demux_out2_1 <= Demux_out2 WHEN enb_1_2048_1 = '1' ELSE
      DPRAM1_bypass_reg;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      register_control_passthrough_3 <= '0';
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        register_control_passthrough_3 <= register_control_passthrough_2;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  
  switch_compare_1 <= '1' WHEN register_control_passthrough_3 > '0' ELSE
      '0';

  Demux_out1_scalarexpand(0) <= Demux_out1;
  Demux_out1_scalarexpand(1) <= Demux_out1;


  Demux_out1_scalarexpand_dtc_gen: FOR ii1 IN 0 TO 1 GENERATE
    Demux_out1_scalarexpand_dtc(ii1) <= resize(Demux_out1_scalarexpand(ii1) & '0' & '0' & '0' & '0' & '0', 32);
  END GENERATE Demux_out1_scalarexpand_dtc_gen;


  FFT_Analysis_Synthesis_Left_out1_signed <= signed(FFT_Analysis_Synthesis_Left_out1);

  Data_Type_Conversion1_out1 <= resize(FFT_Analysis_Synthesis_Left_out1_signed & '0' & '0' & '0' & '0' & '0', 32);

  FFT_Analysis_Synthesis_Right_out1_signed <= signed(FFT_Analysis_Synthesis_Right_out1);

  Data_Type_Conversion2_out1 <= resize(FFT_Analysis_Synthesis_Right_out1_signed & '0' & '0' & '0' & '0' & '0', 32);

  Mux_out1(0) <= Data_Type_Conversion1_out1;
  Mux_out1(1) <= Data_Type_Conversion2_out1;

  
  Switch_out1 <= Demux_out1_scalarexpand_dtc WHEN switch_compare_1 = '0' ELSE
      Mux_out1;

  outputgen: FOR k IN 0 TO 1 GENERATE
    avalon_source_data(k) <= std_logic_vector(Switch_out1(k));
  END GENERATE;

  ce_out <= enb_1_1_1;

END rtl;

