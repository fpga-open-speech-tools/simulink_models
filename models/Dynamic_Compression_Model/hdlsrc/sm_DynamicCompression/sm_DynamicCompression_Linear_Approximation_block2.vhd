-- -------------------------------------------------------------
-- 
-- File Name: /home/cb54103/Documents/fpga-open-speech-tools/simulink_models/models/Dynamic_Compression_Model/hdlsrc/sm_DynamicCompression/sm_DynamicCompression_Linear_Approximation_block2.vhd
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: sm_DynamicCompression_Linear_Approximation_block2
-- Source Path: sm_DynamicCompression/dataplane/Avalon Data Processing/Left Channel Processing/recalculate/Nchan_FbankAGC_AID/Compression_4/Compression_Gain_Calc/Linear_Approximation
-- Hierarchy Level: 7
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.sm_DynamicCompression_dataplane_pkg.ALL;

ENTITY sm_DynamicCompression_Linear_Approximation_block2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        G_high                            :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        G_low                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        addr_low                          :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        alphaX_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        G_Desired                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En28
        );
END sm_DynamicCompression_Linear_Approximation_block2;


ARCHITECTURE rtl OF sm_DynamicCompression_Linear_Approximation_block2 IS

  -- Component Declarations
  COMPONENT sm_DynamicCompression_LSR_N_block2
    PORT( NShifts                         :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          x_in                            :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          x_shifted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En30
          );
  END COMPONENT;

  COMPONENT sm_DynamicCompression_LSL_N_block5
    PORT( NShifts                         :   IN    std_logic_vector(3 DOWNTO 0);  -- ufix4
          x_in                            :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
          x_shifted                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : sm_DynamicCompression_LSR_N_block2
    USE ENTITY work.sm_DynamicCompression_LSR_N_block2(rtl);

  FOR ALL : sm_DynamicCompression_LSL_N_block5
    USE ENTITY work.sm_DynamicCompression_LSL_N_block5(rtl);

  -- Signals
  SIGNAL Unit_Delay_ctrl_const_out        : std_logic;
  SIGNAL delayMatch5_reg                  : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Unit_Delay_ctrl_delay_out        : std_logic;
  SIGNAL Unit_Delay_Initial_Val_out       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL alphaX_in_signed                 : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL addr_low_unsigned                : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL Bit_Slice_out1                   : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL NShifts                          : unsigned(3 DOWNTO 0);  -- ufix4
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL alpha2_NShifts                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL alpha2_NShifts_unsigned          : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL delayMatch_reg                   : vector_of_unsigned32(0 TO 1);  -- ufix32 [2]
  SIGNAL alpha2_NShifts_1                 : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL alpha2_M_bits_NShifts            : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL alpha2_M_bits_NShifts_1          : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL M                                : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL M_1                              : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL M_2_M_bits_NShifts               : unsigned(36 DOWNTO 0);  -- ufix37_En30
  SIGNAL delayMatch1_reg                  : vector_of_signed32(0 TO 1);  -- sfix32 [2]
  SIGNAL alphaX_in_1                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL M_2_M_bits_NShifts_1             : unsigned(36 DOWNTO 0);  -- ufix37_En30
  SIGNAL Subtract1_add_cast               : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL Subtract1_add_cast_1             : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL Subtract1_add_temp               : unsigned(37 DOWNTO 0);  -- ufix38_En30
  SIGNAL x_low                            : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Subtract2_out1                   : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL G_low_signed                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL reduced_reg                      : vector_of_signed32(0 TO 3);  -- sfix32 [4]
  SIGNAL G_low_1                          : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL G_high_signed                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Subtract_sub_cast                : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract_sub_cast_1              : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Delta_G                          : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Delta_G_1                        : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Constant2_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL alpha1_Delta_x                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL alpha1_Delta_x_unsigned          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL alpha1_Delta_x_1                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Product2_cast                    : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Product2_mul_temp                : signed(65 DOWNTO 0);  -- sfix66_En28
  SIGNAL slope                            : signed(64 DOWNTO 0);  -- sfix65_En28
  SIGNAL HwModeRegister4_reg              : vector_of_signed65(0 TO 1);  -- sfix65 [2]
  SIGNAL slope_1                          : signed(64 DOWNTO 0);  -- sfix65_En28
  SIGNAL Subtract2_out1_1                 : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL M_2_2_NShifts                    : signed(96 DOWNTO 0);  -- sfix97_En56
  SIGNAL M_2_2_NShifts_1                  : signed(96 DOWNTO 0);  -- sfix97_En56
  SIGNAL Data_Type_Conversion_out1        : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL delayMatch4_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Compare_To_Constant_out1_1       : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Subtract3_add_cast               : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract3_add_cast_1             : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Subtract3_out1                   : signed(32 DOWNTO 0);  -- sfix33_En28
  SIGNAL Data_Type_Conversion1_out1       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Switch_out1                      : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Unit_Delay_out                   : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL Unit_Delay_out1                  : signed(31 DOWNTO 0);  -- sfix32_En28

  ATTRIBUTE multstyle : string;

BEGIN
  -- Check if |X_in| is less than x_low,
  -- if true, use the low gain instead of
  -- linear interpolation
  -- 
  -- NOTE: When NShifts would be > 15, the output gain is slightly too small.
  -- This is marginal as this volume is below the threshold, but for consistency,
  -- all gains on volumes below the threshold will be set to x_low value, the 
  -- gain applied to an input of 2^-15
  -- Outputs above 85 dBA will be clipped to 85 dBA.

  u_LSR_N : sm_DynamicCompression_LSR_N_block2
    PORT MAP( NShifts => std_logic_vector(NShifts),  -- ufix4
              x_in => std_logic_vector(Constant_out1),  -- ufix32_En30
              x_shifted => alpha2_NShifts  -- ufix32_En30
              );

  u_LSL_N : sm_DynamicCompression_LSL_N_block5
    PORT MAP( NShifts => std_logic_vector(NShifts),  -- ufix4
              x_in => std_logic_vector(Constant2_out1),  -- uint32
              x_shifted => alpha1_Delta_x  -- uint32
              );

  Unit_Delay_ctrl_const_out <= '1';

  delayMatch5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch5_reg <= (OTHERS => '0');
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch5_reg(0) <= Unit_Delay_ctrl_const_out;
        delayMatch5_reg(1 TO 4) <= delayMatch5_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch5_process;

  Unit_Delay_ctrl_delay_out <= delayMatch5_reg(4);

  Unit_Delay_Initial_Val_out <= to_signed(268435456, 32);

  alphaX_in_signed <= signed(alphaX_in);

  addr_low_unsigned <= unsigned(addr_low);

  Bit_Slice_out1 <= addr_low_unsigned(8 DOWNTO 5);

  NShifts <=  NOT Bit_Slice_out1;

  Constant_out1 <= to_unsigned(1073741824, 32);

  alpha2_NShifts_unsigned <= unsigned(alpha2_NShifts);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => to_unsigned(0, 32));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= alpha2_NShifts_unsigned;
        delayMatch_reg(1) <= delayMatch_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  alpha2_NShifts_1 <= delayMatch_reg(1);

  alpha2_M_bits_NShifts <= alpha2_NShifts_unsigned ror 5;

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha2_M_bits_NShifts_1 <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        alpha2_M_bits_NShifts_1 <= alpha2_M_bits_NShifts;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  M <= addr_low_unsigned(4 DOWNTO 0);

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      M_1 <= to_unsigned(16#00#, 5);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        M_1 <= M;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  M_2_M_bits_NShifts <= alpha2_M_bits_NShifts_1 * M_1;

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => to_signed(0, 32));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= alphaX_in_signed;
        delayMatch1_reg(1) <= delayMatch1_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  alphaX_in_1 <= delayMatch1_reg(1);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      M_2_M_bits_NShifts_1 <= to_unsigned(0, 37);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        M_2_M_bits_NShifts_1 <= M_2_M_bits_NShifts;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Subtract1_add_cast <= resize(alpha2_NShifts_1, 38);
  Subtract1_add_cast_1 <= resize(M_2_M_bits_NShifts_1, 38);
  Subtract1_add_temp <= Subtract1_add_cast + Subtract1_add_cast_1;
  x_low <= signed(Subtract1_add_temp(33 DOWNTO 2));

  Subtract2_out1 <= alphaX_in_1 - x_low;

  
  Compare_To_Constant_out1 <= '1' WHEN Subtract2_out1 < to_signed(0, 32) ELSE
      '0';

  G_low_signed <= signed(G_low);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reduced_reg <= (OTHERS => to_signed(0, 32));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        reduced_reg(0) <= G_low_signed;
        reduced_reg(1 TO 3) <= reduced_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_process;

  G_low_1 <= reduced_reg(3);

  G_high_signed <= signed(G_high);

  Subtract_sub_cast <= resize(G_high_signed, 33);
  Subtract_sub_cast_1 <= resize(G_low_signed, 33);
  Delta_G <= Subtract_sub_cast - Subtract_sub_cast_1;

  HwModeRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delta_G_1 <= to_signed(0, 33);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Delta_G_1 <= Delta_G;
      END IF;
    END IF;
  END PROCESS HwModeRegister2_process;


  Constant2_out1 <= to_unsigned(32, 32);

  alpha1_Delta_x_unsigned <= unsigned(alpha1_Delta_x);

  HwModeRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      alpha1_Delta_x_1 <= to_unsigned(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        alpha1_Delta_x_1 <= alpha1_Delta_x_unsigned;
      END IF;
    END IF;
  END PROCESS HwModeRegister3_process;


  Product2_cast <= signed(resize(alpha1_Delta_x_1, 33));
  Product2_mul_temp <= Delta_G_1 * Product2_cast;
  slope <= Product2_mul_temp(64 DOWNTO 0);

  HwModeRegister4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      HwModeRegister4_reg <= (OTHERS => to_signed(0, 65));
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        HwModeRegister4_reg(0) <= slope;
        HwModeRegister4_reg(1) <= HwModeRegister4_reg(0);
      END IF;
    END IF;
  END PROCESS HwModeRegister4_process;

  slope_1 <= HwModeRegister4_reg(1);

  HwModeRegister5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Subtract2_out1_1 <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Subtract2_out1_1 <= Subtract2_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister5_process;


  M_2_2_NShifts <= slope_1 * Subtract2_out1_1;

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      M_2_2_NShifts_1 <= to_signed(0, 97);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        M_2_2_NShifts_1 <= M_2_2_NShifts;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  Data_Type_Conversion_out1 <= M_2_2_NShifts_1(59 DOWNTO 28);

  delayMatch4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch4_reg <= (OTHERS => '0');
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        delayMatch4_reg(0) <= Compare_To_Constant_out1;
        delayMatch4_reg(1) <= delayMatch4_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch4_process;

  Compare_To_Constant_out1_1 <= delayMatch4_reg(1);

  
  switch_compare_1 <= '1' WHEN Compare_To_Constant_out1_1 > '0' ELSE
      '0';

  Subtract3_add_cast <= resize(G_low_1, 33);
  Subtract3_add_cast_1 <= resize(Data_Type_Conversion_out1, 33);
  Subtract3_out1 <= Subtract3_add_cast + Subtract3_add_cast_1;

  Data_Type_Conversion1_out1 <= Subtract3_out1(31 DOWNTO 0);

  
  Switch_out1 <= Data_Type_Conversion1_out1 WHEN switch_compare_1 = '0' ELSE
      G_low_1;

  Unit_Delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Unit_Delay_out <= to_signed(0, 32);
    ELSIF rising_edge(clk) THEN
      IF enb = '1' THEN
        Unit_Delay_out <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Unit_Delay_process;


  
  Unit_Delay_out1 <= Unit_Delay_Initial_Val_out WHEN Unit_Delay_ctrl_delay_out = '0' ELSE
      Unit_Delay_out;

  G_Desired <= std_logic_vector(Unit_Delay_out1);

END rtl;

